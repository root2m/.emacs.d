#+TITLE: LMM Emacs Config
#+AUTHOR: Lmm
#+STARTUP: content indent

* LEXICAL-BINDING
#+BEGIN_SRC emacs-lisp
;;; EmacsConfig.el -*- lexical-binding: t; -*-
#+END_SRC

* CORE SETTINGS
** Config Manage
#+BEGIN_SRC emacs-lisp
  (defun lmm/open-init-file()
    (interactive)
    (find-file (concat user-emacs-directory "init.el")))
  (defun lmm/open-config-org-file()
    (interactive)
    (find-file (concat user-emacs-directory "EmacsConfig.org")))
  (global-set-key (kbd "<f2>") 'lmm/open-config-org-file)

  (defun lmm/open-config-file (file)
    "Open user config FILE."
    (interactive (list (read-file-name "Emacs Config: " user-emacs-directory)))
    (when file (find-file file)))
#+END_SRC

** Server Mode
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook (lambda ()
                               "Start server"
                               (require 'server)
                               (unless (server-running-p)
                                 (server-start))))
#+END_SRC

** Native Comp Support
#+BEGIN_SRC emacs-lisp
  ;; 判断是否支持native-comp
  (when (featurep 'native-compile)
    ;; 关闭native-comp 生成的警告
    (setq native-comp-async-report-warnings-errors nil
          ;; 同步编译
          native-comp-deferred-compilation t
          package-native-compile t))
#+END_SRC

** Yes Or No
#+BEGIN_SRC emacs-lisp
  (setq use-short-answers t)
  (unless (>= emacs-major-version 28)
    (fset 'yes-or-no-p 'y-or-n-p))
  (setq y-or-n-p-use-read-key t
        ;;禁止切换从选择中出来
        read-char-choice-use-read-key t)
  ;; 更多的选项
  (defmacro lmm/read-char-choice (format choices)
    "More option to question. CHOICES is a list
     exp:
     (lmm/read-char-choice format ((?a (body)) (?b (body)) ...))"
    (declare (indent 1) (debug t))
    (let ((ch-list (mapcar (lambda (l)(car l)) choices)))
      `(let ((ch (read-char-choice ,format ',ch-list)))
         (cond ,@(mapcar (lambda (c) (let ((c (car c))
                                           (body (cdr c)))
                                       (cons (list '= c 'ch) body))) choices)))))
#+END_SRC

** System Clipboard
#+BEGIN_SRC emacs-lisp
  ;; 当变量为 t 时，evil 粘贴失效
  (setq select-enable-primary nil)
  ;; 开启系统剪贴板
  (setq select-enable-clipboard t)
#+END_SRC

* PACKAGE MANAGEMENT
** No Littering
#+BEGIN_SRC emacs-lisp
  ;; copy from https://github.com/emacscollective/no-littering

  (defvar lmmv/no-littering-etc-directory
    (expand-file-name (convert-standard-filename "etc/") user-emacs-directory)
    "The directory where packages place their configuration files.
  This variable has to be set before `no-littering' is loaded.")

  (defvar lmmv/no-littering-var-directory
    (expand-file-name (convert-standard-filename "var/") user-emacs-directory)
    "The directory where packages place their persistent data files.
  This variable has to be set before `no-littering' is loaded.")

  ;;;###autoload
  (defun lmm/no-littering-expand-etc (file)
    "Expand filename FILE relative to `lmmv/no-littering-etc-directory'."
    (expand-file-name (convert-standard-filename file)
                      lmmv/no-littering-etc-directory))

  ;;;###autoload
  (defun lmm/no-littering-expand-var (file)
    "Expand filename FILE relative to `lmmv/no-littering-var-directory'."
    (expand-file-name (convert-standard-filename file)
                      lmmv/no-littering-var-directory))

  (make-directory lmmv/no-littering-etc-directory t)
  (make-directory lmmv/no-littering-var-directory t)

  (eval-after-load 'x-win
    (let ((session-dir (lmm/no-littering-expand-var "emacs-session/")))
      `(progn
         (make-directory ,session-dir t)
         (defun emacs-session-filename (session-id)
           "Construct a filename to save the session in based on SESSION-ID.
  This function overrides the one on `x-win' to use `no-littering'
  directories."
           (expand-file-name session-id ,session-dir)))))
  (eval-after-load 'desktop
    `(make-directory ,(lmm/no-littering-expand-var "desktop/") t))

  (eval-after-load 'eshell
    `(make-directory ,(lmm/no-littering-expand-etc "eshell/") t))

  (eval-after-load 'erc
    `(make-directory ,(lmm/no-littering-expand-var "erc/dcc/") t))

  (eval-after-load 'eww
    `(make-directory ,(lmm/no-littering-expand-var "eww/") t))

  (eval-after-load 'gnus
    `(make-directory ,(lmm/no-littering-expand-var "gnus/dribble/") t))

  (eval-after-load 'newsticker
    `(make-directory ,(lmm/no-littering-expand-var "newsticker/") t))

  (eval-after-load 'org
    `(make-directory ,(lmm/no-littering-expand-var "org/") t))
  (eval-after-load 'shadowfile
    `(make-directory ,(lmm/no-littering-expand-var "shadow/") t))

  (eval-after-load 'bbdb
    `(make-directory ,(lmm/no-littering-expand-var "bbdb/") t))

  (eval-after-load 'bookmark+-1
    `(make-directory ,(lmm/no-littering-expand-var "bmkp/") t))

  (eval-after-load 'command-log-mode
    `(make-directory ,(lmm/no-littering-expand-var "command-log-mode-logging/") t))

  (eval-after-load 'company
    `(make-directory ,(lmm/no-littering-expand-var "company/") t))

  (eval-after-load 'elfeed
    `(make-directory ,(lmm/no-littering-expand-var "elfeed/") t))

  (eval-after-load 'emojify
    `(make-directory ,(lmm/no-littering-expand-var "emojify/") t))

  (eval-after-load 'geiser
    `(make-directory ,(lmm/no-littering-expand-var "geiser/") t))

  (eval-after-load 'helm
    `(make-directory ,(lmm/no-littering-expand-var "helm/") t))

  (eval-after-load 'jabber
    `(make-directory ,(lmm/no-littering-expand-var "jabber/avatar-cache/") t))

  (eval-after-load 'jabber
    `(make-directory ,(lmm/no-littering-expand-var "jabber/history/") t))

  (eval-after-load 'lookup
    `(make-directory ,(lmm/no-littering-expand-etc "lookup/") t))

  (eval-after-load 'lsp-mode
    `(make-directory ,(lmm/no-littering-expand-var "lsp/") t))

  (eval-after-load 'org-caldav
    `(make-directory ,(lmm/no-littering-expand-var "org/caldav/save") t))

  (eval-after-load 'projectile
    `(make-directory ,(lmm/no-littering-expand-var "projectile/") t))

  (eval-after-load 'sly
    `(make-directory ,(lmm/no-littering-expand-var "sly/") t))

  (eval-after-load 'sx
    `(make-directory ,(lmm/no-littering-expand-var "sx/cache/") t))

  (eval-after-load 'wl
    `(make-directory ,(lmm/no-littering-expand-etc "wanderlust") t))

  (eval-after-load 'xkcd
    `(make-directory ,(lmm/no-littering-expand-var "xkcd/") t))

  (eval-after-load 'yasnippet
    `(make-directory ,(lmm/no-littering-expand-etc "yasnippet/snippets/") t))


  (setq custom-file                      (lmm/no-littering-expand-etc "custom.el")
        desktop-dirname                  (lmm/no-littering-expand-var "desktop/")
        desktop-path                     (list desktop-dirname)
        eshell-aliases-file              (lmm/no-littering-expand-etc "eshell/aliases")
        eshell-directory-name            (lmm/no-littering-expand-var "eshell/")
        erc-dcc-get-default-directory    (lmm/no-littering-expand-var "erc/dcc/")
        erc-log-channels-directory       (lmm/no-littering-expand-var "erc/log-channels/")
        eww-bookmarks-directory          (lmm/no-littering-expand-var "eww/")
        gnus-dribble-directory           (lmm/no-littering-expand-var "gnus/dribble/")
        gnus-init-file                   (lmm/no-littering-expand-etc "gnus/init.el")
        newsticker-cache-filename        (lmm/no-littering-expand-var "newsticker/cache.el")
        newsticker-dir                   (lmm/no-littering-expand-var "newsticker/data/")
        org-clock-persist-file           (lmm/no-littering-expand-var "org/clock-persist.el")
        org-id-locations-file            (lmm/no-littering-expand-var "org/id-locations.el")
        org-persist-directory            (lmm/no-littering-expand-var "org/persist/")
        org-publish-timestamp-directory  (lmm/no-littering-expand-var "org/timestamps/")
        shadow-info-file                 (lmm/no-littering-expand-var "shadow/info.el")
        shadow-todo-file                 (lmm/no-littering-expand-var "shadow/todo.el")
        abm-file                         (lmm/no-littering-expand-var "autobookmarks.el")
        bbdb-file                        (lmm/no-littering-expand-var "bbdb/bbdb.el")
        bbdb-vcard-directory             (lmm/no-littering-expand-var "bbdb/vcard/")
        bm-repository-file               (lmm/no-littering-expand-var "bm-repository.el")
        bmkp-bmenu-commands-file         (lmm/no-littering-expand-var "bmkp/bmenu-commands.el")
        bmkp-current-bookmark-file       (lmm/no-littering-expand-var "bmkp/current-bookmark.el")
        bmkp-last-bookmark-file          (lmm/no-littering-expand-var "bmkp/last-bookmark.el")
        clm/logging-dir                  (lmm/no-littering-expand-var "command-log-mode/logging/")
        company-statistics-file          (lmm/no-littering-expand-var "company/statistics.el")
        company-tabnine-binaries-folder  (lmm/no-littering-expand-var "company/tabnine-binaries")
        elfeed-db-directory              (lmm/no-littering-expand-var "elfeed/db/")
        elfeed-enclosure-default-dir     (lmm/no-littering-expand-var "elfeed/enclosures/")
        elfeed-score-score-file          (lmm/no-littering-expand-etc "elfeed/score/score.el")
        emms-directory                   (lmm/no-littering-expand-var "emms/")
        emojify-emojis-dir               (lmm/no-littering-expand-var "emojify/")
        geiser-repl-history-filename     (lmm/no-littering-expand-var "geiser/repl-history")
        helm-adaptive-history-file       (lmm/no-littering-expand-var "helm/adaptive-history.el")
        helm-backup-path                 (lmm/no-littering-expand-var "helm/backup/")
        helm-github-stars-cache-file     (lmm/no-littering-expand-var "helm/github-stars-cache.el")
        helm-net-curl-log-file           (lmm/no-littering-expand-var "helm/helm-curl.log")
        jabber-avatar-cache-directory    (lmm/no-littering-expand-var "jabber/avatar-cache")
        jabber-history-dir               (lmm/no-littering-expand-var "jabber/history")
        lookup-init-directory            (lmm/no-littering-expand-etc "lookup/")
        lsp-clojure-workspace-dir        (lmm/no-littering-expand-var "lsp-clojure/workspace/")
        lsp-eslint-library-choices-file  (lmm/no-littering-expand-var "lsp/eslint-library-choices.el")
        lsp-python-ms-dir                (lmm/no-littering-expand-var "lsp-python-ms/")
        lsp-server-install-dir           (lmm/no-littering-expand-var "lsp/server/")
        lsp-session-file                 (lmm/no-littering-expand-var "lsp/session.el")
        lsp-java-workspace-dir           (lmm/no-littering-expand-var "lsp-java/workspace/")
        lsp-java-server-install-dir      (lmm/no-littering-expand-var "lsp-java/eclipse.jdt.ls/server/")
        org-gcal-dir                     (lmm/no-littering-expand-var "org/gcal/")
        org-caldav-backup-file           (lmm/no-littering-expand-var "org/caldav/backup.org")
        org-caldav-save-directory        (lmm/no-littering-expand-var "org/caldav/save")
        org-journal-cache-file           (lmm/no-littering-expand-var "org/journal-cache.el")
        org-recent-headings-save-file    (lmm/no-littering-expand-var "org/recent-headings.el")
        org-registry-file                (lmm/no-littering-expand-var "org/registry.el")
        org-roam-db-location             (lmm/no-littering-expand-var "org/org-roam.db")
        prescient-save-file              (lmm/no-littering-expand-var "prescient-save.el")
        projectile-cache-file            (lmm/no-littering-expand-var "projectile/cache.el")
        projectile-known-projects-file   (lmm/no-littering-expand-var "projectile/known-projects.el")
        sly-mrepl-history-file-name      (lmm/no-littering-expand-var "sly/mrepl-history")
        sx-cache-directory               (lmm/no-littering-expand-var "sx/cache/")
        wl-init-file                     (lmm/no-littering-expand-etc "wanderlust/init.el")
        wl-folders-file                  (lmm/no-littering-expand-etc "wanderlust/folders")
        wl-address-file                  (lmm/no-littering-expand-etc "wanderlust/address")
        wl-alias-file                    (lmm/no-littering-expand-etc "wanderlust/alias")
        wl-x-face-file                   (lmm/no-littering-expand-etc "wanderlust/x-face")
        wl-temporary-file-directory      (lmm/no-littering-expand-var "wanderlust-tmp")
        xkcd-cache-dir                   (lmm/no-littering-expand-var "xkcd/")
        yas-snippet-dirs                 (list (lmm/no-littering-expand-etc "yasnippet/snippets/"))
        abbrev-file-name                 (lmm/no-littering-expand-etc "abbrev.el")
        auto-insert-directory            (lmm/no-littering-expand-etc "auto-insert/")
        auto-save-list-file-prefix       (lmm/no-littering-expand-var "auto-save/sessions/")
        backup-directory-alist           (list (cons "." (lmm/no-littering-expand-var "backup/")))
        bookmark-default-file            (lmm/no-littering-expand-var "bookmark-default.el")
        calc-settings-file               (lmm/no-littering-expand-etc "calc-settings.el")
        diary-file                       (lmm/no-littering-expand-var "diary")
        ecomplete-database-file          (lmm/no-littering-expand-var "ecomplete-database.el")
        ede-project-placeholder-cache-file (lmm/no-littering-expand-var "ede-projects.el")
        eudc-options-file                (lmm/no-littering-expand-etc "eudc-options.el")
        filesets-menu-cache-file         (lmm/no-littering-expand-var "filesets-menu-cache.el")
        gamegrid-user-score-file-directory (lmm/no-littering-expand-var "gamegrid-user-score/")
        ido-save-directory-list-file     (lmm/no-littering-expand-var "ido-save-directory-list.el")
        image-dired-db-file              (lmm/no-littering-expand-var "image-dired/db.el")
        image-dired-dir                  (lmm/no-littering-expand-var "image-dired/")
        image-dired-gallery-dir          (lmm/no-littering-expand-var "image-dired/gallery/")
        image-dired-temp-image-file      (lmm/no-littering-expand-var "image-dired/temp-image")
        image-dired-temp-rotate-image-file (lmm/no-littering-expand-var "image-dired/temp-rotate-image")
        kkc-init-file-name               (lmm/no-littering-expand-var "kkc-init.el")
        multisession-directory           (lmm/no-littering-expand-var "multisession/")
        nsm-settings-file                (lmm/no-littering-expand-var "nsm-settings.el")
        project-list-file                (lmm/no-littering-expand-var "project-list.el")
        quickurl-url-file                (lmm/no-littering-expand-var "quickurl-url.el")
        rcirc-log-directory              (lmm/no-littering-expand-var "rcirc-log/")
        recentf-save-file                (lmm/no-littering-expand-var "recentf-save.el")
        remember-data-file               (lmm/no-littering-expand-var "remember/data")
        remember-data-directory          (lmm/no-littering-expand-var "remember/data.d/")
        save-place-file                  (lmm/no-littering-expand-var "save-place.el")
        savehist-file                    (lmm/no-littering-expand-var "savehist.el")
        srecode-map-save-file            (lmm/no-littering-expand-var "srecode-map.el")
        semanticdb-default-save-directory (lmm/no-littering-expand-var "semantic/")
        shared-game-score-directory      (lmm/no-littering-expand-var "shared-game-score/")
        timeclock-file                   (lmm/no-littering-expand-var "timeclock")
        tramp-auto-save-directory        (lmm/no-littering-expand-var "tramp/auto-save/")
        tramp-persistency-file-name      (lmm/no-littering-expand-var "tramp/persistency.el")
        type-break-file-name             (lmm/no-littering-expand-var "type-break.el")
        url-cache-directory              (lmm/no-littering-expand-var "url/cache/")
        url-configuration-directory      (lmm/no-littering-expand-var "url/")
        url-cookie-file                  (lmm/no-littering-expand-var "url/cookies.el")
        url-history-file                 (lmm/no-littering-expand-var "url/history.el")

  ;;; Third-party packages

        ac-comphist-file                 (lmm/no-littering-expand-var "ac-comphist.el")
        amx-save-file                    (lmm/no-littering-expand-var "amx-save.el")
        anaconda-mode-installation-directory (lmm/no-littering-expand-var "anaconda-mode/")
        annotate-file                    (lmm/no-littering-expand-var "annotations.el")
        async-byte-compile-log-file      (lmm/no-littering-expand-var "async-bytecomp.log")
        auto-package-update-last-update-day-path (lmm/no-littering-expand-var "auto-package-update-last-update-day")
        bookiez-file                     (lmm/no-littering-expand-var "bookiez")
        cider-repl-history-file          (lmm/no-littering-expand-var "cider-repl-history.el")
        code-review-db-database-file     (lmm/no-littering-expand-var "code-review/database.sqlite")
        code-review-download-dir         (lmm/no-littering-expand-var "code-review/downloads/")
        code-review-log-file             (lmm/no-littering-expand-var "code-review/log")
        conventional-changelog-tmp-dir   (lmm/no-littering-expand-var "conventional-changelog/")
        dap-breakpoints-file             (lmm/no-littering-expand-var "dap/breakpoints.el")
        dap-java-test-runner             (lmm/no-littering-expand-var "lsp-java/eclipse.jdt.ls/test-runner/junit-platform-console-standalone.jar")
        dap-utils-extension-path         (lmm/no-littering-expand-var "dap/extensions/")
        debbugs-gnu-persistency-file     (lmm/no-littering-expand-var "debbugs.el")
        devdocs-browser-cache-directory  (lmm/no-littering-expand-var "devdocs/browser-cache/")
        devdocs-data-dir                 (lmm/no-littering-expand-var "devdocs/data/")
        dired-recent-directories-file    (lmm/no-littering-expand-var "dired-recent-directories.el")
        dirvish-cache-dir                (lmm/no-littering-expand-var "dirvish/cache")
        elbank-data-file                 (lmm/no-littering-expand-var "elbank-data.el")
        elmo-msgdb-directory             (lmm/no-littering-expand-var "elmo/")
        elmo-split-log-file              (lmm/no-littering-expand-var "elmo/split-log")
        elpher-bookmarks-file            (lmm/no-littering-expand-var "elpher-bookmarks.el")
        epkg-repository                  (lmm/no-littering-expand-var "epkgs/")
        equake-persistent-display-file   (lmm/no-littering-expand-var "equake-persistent-display")
        fontaine-latest-state-file       (lmm/no-littering-expand-var "fontaine-latest-state.eld")
        forge-database-file              (lmm/no-littering-expand-var "forge/database.sqlite")
        forge-post-directory             (lmm/no-littering-expand-var "forge/posts/")
        geben-temporary-file-directory   (lmm/no-littering-expand-var "geben/")
        hackernews-visited-links-file    (lmm/no-littering-expand-var "hackernews/visited-links.el")
        historian-save-file              (lmm/no-littering-expand-var "historian-save.el")
        indium-workspace-file            (lmm/no-littering-expand-var "indium/workspaces.el")
        irfc-directory                   (lmm/no-littering-expand-var "irfc/")
        irony-user-dir                   (lmm/no-littering-expand-var "irony/")
        keyfreq-file                     (lmm/no-littering-expand-var "keyfreq.el")
        keyfreq-file-lock                (lmm/no-littering-expand-var "keyfreq.lock")
        libbcel-oauth-store-filename     (lmm/no-littering-expand-var "libbcel-oauth-store.el.gpg")
        litable-list-file                (lmm/no-littering-expand-var "litable-list.el")
        logview-cache-filename           (lmm/no-littering-expand-var "logview-cache")
        logview-views-file               (lmm/no-littering-expand-etc "logview-views")
        magithub-dir                     (lmm/no-littering-expand-var "magithub/")
        magithub-cache-file              (lmm/no-littering-expand-var "magithub/cache.el")
        mc/list-file                     (lmm/no-littering-expand-var "mc-list.el")
        meghanada-server-install-dir     (lmm/no-littering-expand-var "meghanada/")
        multi-compile-history-file       (lmm/no-littering-expand-var "multi-compile-history.el")
        nix-buffer-directory-name        (lmm/no-littering-expand-var "nix-buffer/")
        nomad-tramp-script-directory     (lmm/no-littering-expand-var "nomad-tramp/")
        ;; The value of this variable MUST NOT end with ".el" but the
        ;; actual file name MUST end with ".el".  Use "git blame" for
        ;; more information.
        notmuch-init-file                (lmm/no-littering-expand-etc "notmuch-init")
        nov-save-place-file              (lmm/no-littering-expand-var "nov-save-place.el")
        omnisharp-cache-directory        (lmm/no-littering-expand-var "omnisharp/cache")
        package-quickstart-file          (lmm/no-littering-expand-var "package-quickstart.el")
        pandoc-data-dir                  (lmm/no-littering-expand-etc "pandoc-mode/")
        pcache-directory                 (lmm/no-littering-expand-var "pcache/")
        pdf-view-restore-filename        (lmm/no-littering-expand-var "pdf-view-restore.el")
        persist--directory-location      (lmm/no-littering-expand-var "persist/")
        persistent-scratch-save-file     (lmm/no-littering-expand-var "persistent-scratch.el")
        persp-save-dir                   (lmm/no-littering-expand-var "persp-mode/")
        psession-elisp-objects-default-directory (lmm/no-littering-expand-var "psession/")
        purpose-default-layout-file      (lmm/no-littering-expand-etc "window-purpose/default-layout.el")
        purpose-layout-dirs              (list (lmm/no-littering-expand-etc "window-purpose/layouts/"))
        pyim-dcache-directory            (lmm/no-littering-expand-var "pyim/dcache/")
        quack-dir                        (lmm/no-littering-expand-var "quack/")
        rfc-mode-directory               (lmm/no-littering-expand-var "rfc-mode/")
        request-storage-directory        (lmm/no-littering-expand-var "request/storage/")
        rime-user-data-dir               (lmm/no-littering-expand-var "rime/")
        rmh-elfeed-org-files             (list (lmm/no-littering-expand-var "elfeed/rmh-elfeed.org"))
        runner-init-file                 (lmm/no-littering-expand-var "runner-init.el")
        save-kill-file-name              (lmm/no-littering-expand-var "save-kill.el")
        save-visited-files-location      (lmm/no-littering-expand-var "save-visited-files-location")
        smex-save-file                   (lmm/no-littering-expand-var "smex-save.el")
        speed-type-gb-dir                (lmm/no-littering-expand-var "speed-type/")
        svg-lib-icons-dir                (lmm/no-littering-expand-var "svg-lib/icons/")
        tldr-directory-path              (lmm/no-littering-expand-var "tldr/")
        transient-history-file           (lmm/no-littering-expand-var "transient/history.el")
        transient-levels-file            (lmm/no-littering-expand-etc "transient/levels.el")
        transient-values-file            (lmm/no-littering-expand-etc "transient/values.el")
        treemacs-persist-file            (lmm/no-littering-expand-var "treemacs/persist.org")
        treemacs-last-error-persist-file (lmm/no-littering-expand-var "treemacs/persist-last-error.org")
        undo-fu-session-directory        (lmm/no-littering-expand-var "undo-fu-session/")
        undohist-directory               (lmm/no-littering-expand-var "undohist/")
        undo-tree-history-directory-alist (list (cons "." (lmm/no-littering-expand-var "undo-tree-hist/")))
        user-emacs-ensime-directory      (lmm/no-littering-expand-var "ensime/")
        vimish-fold-dir                  (lmm/no-littering-expand-var "vimish-fold/")
        x86-lookup-cache-directory       (lmm/no-littering-expand-var "x86-lookup/cache/")
        treesit--install-language-grammar-out-dir-history (list (lmm/no-littering-expand-var "tree-sitter"))
        treesit-extra-load-path (list (lmm/no-littering-expand-var "tree-sitter")))
#+END_SRC

** Setup package.el to work with MELPA.
修改国内镜像源
#+BEGIN_SRC emacs-lisp
  ;; (require 'package)
  (setq package-archives '(("gnu"   . "https://elpa.zilongshanren.com/gnu/")
                           ("melpa" . "https://elpa.zilongshanren.com/melpa/")
                           ("org" . "https://elpa.zilongshanren.com/org/")))
  ;; 合并 autoload io 快速启动，如果新安装包了之后需要执行 package-quickstart-refresh
  (setq package-quickstart t)
#+END_SRC

** Straight -- git package download manager
#+BEGIN_SRC emacs-lisp
  (setq straight-check-for-modifications 'never)
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 7))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  (add-to-list 'straight-built-in-pseudo-packages 'org)
#+END_SRC

** Package Config Manager -- use-package
包管理器
#+BEGIN_SRC emacs-lisp
  (when (< emacs-major-version 29)
    (straight-use-package 'use-package)
    (eval-when-compile
      (require 'use-package)))
  (setq use-package-hook-name-suffix nil) ;;停止在:hook 当中添加-hook后缀

  ;; how to use use-package.
  (use-package some-package-name
    :disabled ;;不安装加载该包
    :no-require t; 不引入
    :ensure t ;;确保软件包会自动安装
    :defer t ;;延迟t秒加载包（require 'some-package-name)
    :init  ;;加载包之前执行的代码
    :config  ;;加载包之后执行的代码
    :hook  ;;钩子, 默认启用 defer t
    :commands ;;延迟加载，命令触发
    :if       ;;条件返回 non-nil 加载
    )

  ;; dependencies
  (use-package diminish
    :straight t)
#+END_SRC

* HELP
** Default Help System
#+BEGIN_SRC emacs-lisp
  (use-package help
    :init
    ;; 自动获取焦点
    (setq help-window-select t)
    :commands help
    :config
    (add-hook 'help-mode-hook (lambda ()(setq-local mode-line-format nil))))
#+END_SRC

** Helpful -- 更好的帮助信息
#+BEGIN_SRC emacs-lisp
  (use-package helpful
    :straight t
    :bind
    (:map help-map
          ("SPC" . helpful-at-point)
          ("f" . helpful-callable)
          ("F" . describe-face)
          ("v" . helpful-variable)
          ("k" . helpful-key)
          ("C" . helpful-command))
    :init
    (setq helpful-max-buffers 2)
    (setq helpful-switch-buffer-function
          (lambda (buffer-name &rest args)
            (if (equal major-mode 'helpful-mode)
                (pop-to-buffer buffer-name '((display-buffer-same-window)))
              (pop-to-buffer buffer-name '((display-buffer-at-bottom) . ((window-height . 0.4)))))))
    :config
    (add-hook 'helpful-mode-hook (lambda()(setq-local mode-line-format nil))))
#+END_SRC

* KEY BIND
** Simple Key Bind
[[https://github.com/noctuid/general.el][General]] 直观的按键绑定
#+BEGIN_SRC emacs-lisp
  (use-package general
    :straight t
    :config
    (general-evil-setup t))
#+END_SRC
#+BEGIN_SRC emacs-lisp
  ;; ESC Cancels All
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  ;; Rebind C-u
  (global-set-key (kbd "C-M-u") 'universal-argument)
  (define-key universal-argument-map (kbd "C-M-u") 'universal-argument-more)
#+END_SRC

** Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :straight t)
#+END_SRC

** Mouse Key Bind
#+BEGIN_SRC emacs-lisp
  (unless (< emacs-major-version 29)
    (setq pixel-scroll-precision-large-scroll-height 10)
    (setq pixel-scroll-precision-interpolation-factor 10)
    (add-hook 'after-init-hook 'pixel-scroll-precision-mode))
#+END_SRC

** Which Key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :straight t
    :hook
    (after-init-hook . which-key-mode)
    )
#+END_SRC

** Utils
#+BEGIN_SRC emacs-lisp
  (defmacro +key-dispath-command-def (name callback delay put-overlay &rest keybinds)
    "NAME: 函数名称。
  CALLBACK: 当用户在指定时间内没有输入或输入无效字符时，将调用的函数。
  DELAY: 等待用户输入的时间，单位为秒。
  PUT-OVERLAY: 可选参数，用于控制是否以及如何显示一个覆盖层，指示用户输入的字符。可以是以下值之一：
       - nil: 不显示覆盖层。
       - override-char: 在光标位置显示一个覆盖层，覆盖当前字符。
       - after-char: 在光标位置后显示一个覆盖层。
       - function：调用该函数来创建和放置覆盖层。
       - overlay object：使用该覆盖层对象。
  KEYBINDS: 一个由键绑定组成的列表，每个键绑定都是一个列表，格式为 (key command)，其中 key 是一个字符，command 是一个要执行的命令。"
    (declare (indent 1))
    (let ((ov-name (intern (format "%s-overlay" name)))
          (map-name (intern (format "%s-map" name))))
      `(progn
         ,(when put-overlay `(defvar ,ov-name (make-overlay 0 0)))
         (defvar-keymap ,map-name ,@keybinds)
         (defun ,name ()
           (interactive)
           (let* ((this-key (this-command-keys))
                  (p (point))
                  (overlay
                   ,(let ((o (eval put-overlay)))
                      (cond ((null o) nil)
                            ((eq o 'override-char)
                             `(cond (executing-kbd-macro nil)
                                    (buffer-read-only nil)
                                    ((and (eobp) (bolp))
                                     (overlay-put ,ov-name 'display (concat "\n" this-key))
                                     (move-overlay ,ov-name (1- p) p))
                                    ((eolp)
                                     (overlay-put ,ov-name 'display (concat this-key "\n"))
                                     (move-overlay ,ov-name p (1+ p)))
                                    (t
                                     (overlay-put ,ov-name 'display this-key)
                                     (move-overlay ,ov-name p (1+ p)))))
                            ((eq o 'after-char)
                             `(cond (executing-kbd-macro nil)
                                    (buffer-read-only nil)
                                    (t
                                     (overlay-put ,ov-name 'after-string this-key)
                                     (move-overlay ,ov-name p p))))
                            ((functionp o)
                             `(funcall ,put-overlay))
                            ((overlayp o)
                             `(cond (executing-kbd-macro nil)
                                    (buffer-read-only nil)
                                    (t
                                     (move-overlay ,put-overlay p (1+ p))))))))
                  ;; if use read-event delay, this-command-keys can't read read-event keys.
                  (evt (with-timeout (,delay nil)
                         (read-event)))
                  command)
             ,(when put-overlay '(and overlay (delete-overlay overlay)))
             (cond ((and (characterp evt)
                         (setq command (lookup-key ,map-name (char-to-string evt))))
                    (let ((this-command command))
                     (call-interactively command)))
                   ((null evt)
                    (let ((this-command ,callback))
                      (call-interactively ,callback)))
                   (t
                    (let ((this-command ,callback))
                      (call-interactively ,callback))
                    (setq unread-command-events
                          (append unread-command-events (list evt))))))))))
#+END_SRC

* UI
** Display Line Numbers and Truncated Lines
#+BEGIN_SRC emacs-lisp
  (use-package simple
    :hook
    (after-init-hook . global-visual-line-mode))

  (use-package hl-line
    :defer t)

  ;; 开启行号显示
  (use-package display-line-numbers
    :init
    (setq display-line-numbers-type 'relative
          display-line-numbers-width 3
          display-line-numbers-widen t)
    :hook
    (text-mode-hook . display-line-numbers-mode)
    (prog-mode-hook . display-line-numbers-mode)
    (conf-mode-hook . display-line-numbers-mode)
    (org-mode-hook . +display-line-numbers-turn-off-mode)
    :config
    (defun +display-line-numbers-turn-off-mode ()
      (display-line-numbers-mode -1)))
#+END_SRC

** Cursor Face
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC

** Bell
#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil)
  (setq ring-bell-function 'ignore)
#+END_SRC

** 80 line
#+BEGIN_SRC emacs-lisp
  (when (boundp 'display-fill-column-indicator)
    (setq-default indicate-buffer-boundaries 't)
    (setq-default fill-column 80)
    ;; (add-hook 'prog-mode-hook 'display-fill-column-indicator-mode)
    )
#+END_SRC

** Icon Display
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :straight t
    :defer t)
  (use-package nerd-icons
    :straight t
    :defer t)
#+END_SRC

** Dashboard
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :straight t
    ;; :hook (after-init-hook . dashboard-setup-startup-hook)
    :init
    ;; 居中对齐
    (setq dashboard-center-content t
          dashboard-set-footer nil
          dashboard-startup-banner (cons (concat lmmv/no-littering-etc-directory "dashboard/banners/lemacs_logo.png")
                                         (concat lmmv/no-littering-etc-directory "dashboard/banners/lemacs_logo.txt"))
          dashboard-banner-logo-title nil
          dashboard-image-banner-max-height (/ (window-pixel-height) 2))
    ;;(setq dashboard-show-shortcuts nil)
    (setq dashboard-items '((projects . 5)
                            (bookmarks . 5)
                            (agenda . 5)
                            (registers . 5)))
    ;; 启用图标
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)
    ;; 主页设置
    (setq dashboard-set-navigator nil)
    ;; Format: "(icon title help action face prefix suffix)"
    (setq dashboard-navigator-buttons
          `(;; line1
            ((" "
              ""
              "Git Homepage"
              (lambda (&rest _) (if (string-match "WSL" operating-system-release)
                                    (shell-command "/mnt/c/Windows/explorer.exe https://github.com/root2m " nil nil)
                                  (browse-url "https://github.com/root2m")))
                                  nil "" "")
             ;; ("★" "Star" "Show stars" (lambda (&rest _) (show-stars)) warning)
             ;; ("?" "" "?/h" #'show-help nil "<" ">")
             )
            ;; line 2
            ;; ((,(all-the-icons-faicon "linkedin" :height 1.1 :v-adjust 0.0)
            ;;   "Linkedin"
            ;;   ""
            ;;   (lambda (&rest _) (browse-url "homepage")))
            ;;  ("⚑" nil "Show flags" (lambda (&rest _) (message "flag")) error))
            ))
    :config
    (defun dashboard-open-projectile (list-size)
      (insert (propertize "  " 'face '(:inherit dashboard-heading :height 1.2)))
      (widget-create 'item
                     :tag (propertize "Open Projectile" 'face '(:inherit dashboard-heading :weight 'bold)
                                      'cursor-face '(:foreground "cyan" :height 1.2 :underline (:position 0))
                                      )
                     :action (lambda (&rest _) (call-interactively 'projectile-switch-project))
                     ;; :button-face 'dashboard-heading
                     :mouse-face 'highlight
                     :format "%[%t%]"))

    (defun dashboard-open-recentf (list-size)
      (insert (propertize "  " 'face '(:inherit dashboard-heading :height 1.2)))
      (widget-create 'item
                     :tag (propertize "Open Recent File" 'face '(:inherit dashboard-heading :weight 'bold)
                                      'cursor-face '(:foreground "cyan" :height 1.2 :underline (:position 0)))
                     :action (lambda (&rest _) (call-interactively 'recentf-open))
                     ;; :button-face 'dashboard-heading
                     :mouse-face 'highlight
                     :format "%[%t%]"))

    (defun dashboard-open-bookmark (list-size)
      (insert (propertize "  " 'face '(:inherit dashboard-heading :height 1.2)))
      (widget-create 'item
                     :tag (propertize "Open Bookmark" 'face '(:inherit dashboard-heading :weight 'bold)
                                      'cursor-face '(:foreground "cyan" :height 1.2 :underline (:position 0)))
                     :action (lambda (&rest _) (call-interactively 'bookmark-jump))
                     ;; :button-face 'dashboard-heading
                     :mouse-face 'highlight
                     :format "%[%t%]"))

    (defun dashboard-open-org-agenda (list-size)
      (insert (propertize "  " 'face '(:inherit dashboard-heading :height 1.2)))
      (widget-create 'item
                     :tag (propertize "Open Org Agenda" 'face '(:inherit dashboard-heading :weight 'bold)
                                      'cursor-face '(:foreground "cyan" :height 1.2 :underline (:position 0)))
                     :action (lambda (&rest _) (call-interactively 'org-agenda-list))
                     ;; :button-face 'dashboard-heading
                     :mouse-face 'highlight
                     :format "%[%t%]"))

    (setq dashboard-items '((open-recentf . 0)
                            (open-projectile . 0)
                            (open-bookmark . 0)
                            (open-org-agenda . 0)))

    (setq dashboard-item-generators (append dashboard-item-generators '((open-recentf . dashboard-open-recentf)
                                                                        (open-projectile . dashboard-open-projectile)
                                                                        (open-bookmark . dashboard-open-bookmark)
                                                                        (open-org-agenda . dashboard-open-org-agenda))))

    (define-key dashboard-mode-map "j" 'widget-forward)
    (define-key dashboard-mode-map "n" 'widget-forward)
    (define-key dashboard-mode-map "l" 'widget-forward)
    (define-key dashboard-mode-map "k" 'widget-backward)
    (define-key dashboard-mode-map "p" 'widget-backward)
    (define-key dashboard-mode-map "h" 'widget-backward)
    ;;启用dashboard
    ;; (dashboard-setup-startup-hook)
    ;; emacsclient启动时为dashboard
    ;; (setq initial-buffer-choice '(lambda () (get-buffer "*dashboard*")))
    :hook
    (emacs-startup-hook . (lambda ()
                            (when (< (length command-line-args) 2)
                              (dashboard-open))
                            (setq initial-buffer-choice 'dashboard-open)))
    (dashboard-mode-hook . (lambda ()
                             (cursor-face-highlight-mode t)
                             (widget-forward (1+ (or (and dashboard-set-navigator
                                                          (length dashboard-navigator-buttons))
                                                     0)))
                             (setq-local cursor-type nil
                                         mode-line-format nil
                                         doom-modeline-mode-alist nil)
                             (when (featurep 'evil)
                               (evil-define-key* 'normal dashboard-mode-map
                                 "j" 'widget-forward
                                 "l" 'widget-forward
                                 "k" 'widget-backward
                                 "h" 'widget-backward)
                               (evil-normal-state)
                               (setq-local evil-normal-state-cursor '(bar . 0)
                                           ))))
    )
#+END_SRC

** Posframe
#+BEGIN_SRC emacs-lisp
  (use-package posframe
    :straight t
    :defer t
    )
#+END_SRC

** Face Theme
#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :straight t
    :hook
    (after-init-hook . (lambda ()(load-theme 'doom-dracula t)))
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled
    ;; (load-theme 'doom-dracula t)
    ;; Treemacs hl-line-mode bug
    (set-face-background 'line-number-current-line (face-background 'default))
    ;; (doom-themes-visual-bell-config)
   )
#+END_SRC

** Modeline Config
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :straight t
    :init
    (setq doom-modeline-modal-icon nil)
    :hook
    (after-init-hook . doom-modeline-mode)
    :config
    (defvar moon-icons ["" "" "" "" "" "" "" "" "" "" "" "" "" ""
                        "" "" "" "" "" "" "" "" "" "" "" "" "" ""])
    (defvar moon-count (length moon-icons))
    (defvar moon-current-index 0)
    (defun moon-get-icon()
      (when (>= moon-current-index moon-count)
        (setq moon-current-index 0))
      (prog1
          (propertize (aref moon-icons moon-current-index)
                      'face `(:foreground ,(doom-color 'orange)))
        (setq moon-current-index (1+ moon-current-index))))

    ;; look up doom-modeline-format--main
    ;; look up doom-modeline-segment--misc-info
    (add-to-list 'global-mode-string " ")
    (add-to-list 'global-mode-string '(:eval (moon-get-icon))))

  (use-package moody
    :disabled
    :no-require t
    :straight t
    :config
    (setq x-underline-at-descent-line t)
    (moody-replace-mode-line-buffer-identification)
    (moody-replace-vc-mode)
    (moody-replace-eldoc-minibuffer-message-function)
    )
#+END_SRC

** Pair Color Config
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :straight t
    :hook
    (prog-mode-hook . rainbow-delimiters-mode))
#+END_SRC

** Fonts 字体配置
*** frame default font
#+BEGIN_SRC emacs-lisp
  (let ((fonts (font-family-list)))
   (cond ((member "JetBrainsMono Nerd Font" fonts)
         (add-to-list 'default-frame-alist '(font . "JetBrainsMono Nerd Font-14")))
        ((member "Fira Code" fonts)
         (add-to-list 'default-frame-alist '(font . "Fira Code-14")))
        ((member "Source Code Pro" fonts)
         (add-to-list 'default-frame-alist '(font . "Source Code Pro-14")))))
#+END_SRC

*** ligature 连体字符配置
#+BEGIN_SRC emacs-lisp
  ;; Fira Code Symbol 字符集
  ;; www  \ue100     **   \ue101    ***  \ue102    **/  \ue103
  ;;  *>  \ue104     */   \ue105     \\  \ue106    \\\  \ue107
  ;;  {-  \ue108     []   \ue109     ::  \ue10a    :::  \ue10b
  ;;  :=  \ue10c     !!   \ue10d     !=  \ue10e    !==  \ue10f
  ;;  -}  \ue110     --   \ue111    ---  \ue112    -->  \ue113
  ;;  ->  \ue114    ->>   \ue115     -<  \ue116    -<<  \ue117
  ;;  -~  \ue118     #{   \ue119     #[  \ue11a     ##  \ue11b
  ;; ###  \ue11c   ####   \ue11d     #(  \ue11e     #?  \ue11f
  ;;  #_  \ue120    #_(   \ue121     .-  \ue122     .=  \ue123
  ;;  ..  \ue124    ..<   \ue125    ...  \ue126     ?=  \ue127
  ;;  ??  \ue128     ;;   \ue129     /*  \ue12a    /**  \ue12b
  ;;  /=  \ue12c    /==   \ue12d     />  \ue12e     //  \ue12f
  ;; ///  \ue130     &&   \ue131     ||  \ue132    ||=  \ue133
  ;;  |=  \ue134     |>   \ue135     ^=  \ue136     $>  \ue137
  ;;  ++  \ue138    +++   \ue139     +>  \ue13a     +>  \ue13a
  ;; =:=  \ue13b     ==   \ue13c    ===  \ue13d    ==>  \ue13e
  ;;  =>  \ue13f    =>>   \ue140     <=  \ue141    =<<  \ue142
  ;; =/=  \ue143     >-   \ue144     >=  \ue145    >=>  \ue146
  ;;  >>  \ue147    >>-   \ue148    >>=  \ue149    >>>  \ue14a
  ;;  <*  \ue14b    <*>   \ue14c     <|  \ue14d    <|>  \ue14e
  ;;  <$  \ue14f    <$>   \ue150   <!--  \ue151     <-  \ue152
  ;; <--  \ue153    <->   \ue154     <+  \ue155    <+>  \ue156
  ;;  <=  \ue157    <==   \ue158    <=>  \ue159    <=<  \ue15a
  ;;  <>  \ue15b     <<   \ue15c    <<-  \ue15d    <<=  \ue15e
  ;; <<<  \ue15f     <~   \ue160    <~~  \ue161     </  \ue162
  ;; </>  \ue163     ~@   \ue164     ~-  \ue165     ~=  \ue166
  ;;  ~>  \ue167     ~~   \ue168    ~~>  \ue169     %%  \ue16a
  ;;   x  \ue16b      :   \ue16c      +  \ue16d      *  \ue16f
  ;; (when (member "Fira Code Symbol" (font-family-list))
  ;;   (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol"))

  ;; Install Doc: https://github.com/tonsky/FiraCode/wiki/Emacs-instructions
  (defun fira-code-mode--make-alist (list)
    "Generate prettify-symbols alist from LIST."
    (let ((idx -1))
      (mapcar
       (lambda (s)
         (setq idx (1+ idx))
         (let* ((code (+ #Xe100 idx))
                (width (string-width s))
                (prefix ())
                (suffix '(?\s (Br . Br)))
                (n 1))
           (while (< n width)
             (setq prefix (append prefix '(?\s (Br . Bl))))
             (setq n (1+ n)))
           (cons s (append prefix suffix (list (decode-char 'ucs code))))))
       list)))

  (defconst fira-code-mode--ligatures
    '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
      "{-" "[]" "::" ":::" ":=" "!!" "!=" "!==" "-}"
      "--" "---" "-->" "->" "->>" "-<" "-<<" "-~"
      "#{" "#[" "##" "###" "####" "#(" "#?" "#_" "#_("
      ".-" ".=" ".." "..<" "..." "?=" "??" ";;" "/*"
      "/**" "/=" "/==" "/>" "//" "///" "&&" "||" "||="
      "|=" "|>" "^=" "$>" "++" "+++" "+>" "=:=" "=="
      "===" "==>" "=>" "=>>" "<=" "=<<" "=/=" ">-" ">="
      ">=>" ">>" ">>-" ">>=" ">>>" "<*" "<*>" "<|" "<|>"
      "<$" "<$>" "<!--" "<-" "<--" "<->" "<+" "<+>" "<="
      "<==" "<=>" "<=<" "<>" "<<" "<<-" "<<=" "<<<" "<~"
      "<~~" "</" "</>" "~@" "~-" "~=" "~>" "~~" "~~>" "%%"
      "x" ":" "+" "+" "*"))

  (defvar fira-code-mode--old-prettify-alist)

  (defun fira-code-mode--enable ()
    "Enable Fira Code ligatures in current buffer."
    (if (member "Fira Code Symbol" (font-family-list))
        (progn
          (setq-local fira-code-mode--old-prettify-alist prettify-symbols-alist)
          (setq-local prettify-symbols-alist (append (fira-code-mode--make-alist fira-code-mode--ligatures) fira-code-mode--old-prettify-alist))
          (prettify-symbols-mode t))
      (user-error "Fira Code Symbol Not Found, Enable Failed")))

  (defun fira-code-mode--disable ()
    "Disable Fira Code ligatures in current buffer."
    (setq-local prettify-symbols-alist fira-code-mode--old-prettify-alist)
    (prettify-symbols-mode -1))

  (define-minor-mode fira-code-mode
    "Fira Code ligatures minor mode"
    :lighter " Fira Code"
    (setq-local prettify-symbols-unprettify-at-point 'right-edge)
    (if fira-code-mode
        (fira-code-mode--enable)
      (fira-code-mode--disable)))

  (defun fira-code-mode--setup ()
    "Setup Fira Code Symbols"
    (set-fontset-font t '(#Xe100 . #Xe16f) "Fira Code Symbol"))

  ;; (add-hook 'prog-mode-hook 'fira-code-mode)

#+END_SRC

*** other config options
#+BEGIN_SRC emacs-lisp
  ;; 字符集配置
  ;; (set-fontset-font t 'han "font family name")

  ;; 字体缩放配置
  ;; (add-to-list 'face-font-rescale-alist '("font family name" . 1.2))

  ;; 行距配置
  ;; (setq-default line-spacing 1)
#+END_SRC

*** utils
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-text-scale()
    "Change font size"
    ;; 减小字体
    ("j" text-scale-increase "Text Scale Increase")
    ;; 增大字体
    ("k" text-scale-decrease "Text Scale Decrease")
    ;; text-scale-adjust 按键监听，＋ － 或 0 重置，q 退出
    ("q" nil "Quit ! ! !"))
#+END_SRC

** Whitespace Config
#+BEGIN_SRC emacs-lisp
  ;; (setq-default show-trailing-whitespace nil)
  ;; (defun lmm/show-trailing-whitespace()
  ;;   "Enable display of trailing whitespace in this buffer."
  ;;   (setq-local show-trailing-whitespace t))
  ;; (dolist (hook '(prog-mode-hook text-mode-hook conf-mode-hook))
  ;;         (add-hook hook 'lmm/show-trailing-whitespace))

  (dolist (hook '(prog-mode-hook))
    (add-hook hook (lambda()
                     "Enable highlight whitespace"
                     (setq-local whitespace-style '(face trailing lines-tail)
                                 whitespace-line-column 80)
                     (whitespace-mode t))))

  (dolist (hook '(org-mode-hook text-mode-hook))
    (add-hook hook (lambda()
                     "Enable highlight whitespace"
                     (setq-local whitespace-style '(face trailing))
                     (whitespace-mode t))))
#+END_SRC

** Beautiful Code
*** hl-todo
#+BEGIN_SRC emacs-lisp
  (use-package hl-todo
    :straight t
    :hook
    (after-init-hook . global-hl-todo-mode))
#+END_SRC

** Popup
#+BEGIN_SRC emacs-lisp
  (use-package popup
    :straight t
    :no-require t)
#+END_SRC

** Set alpha
#+BEGIN_SRC emacs-lisp
  (defun lmm/alpha-increase()
    (interactive)
    (when (>= emacs-major-version 29)
      (let* ((wf (window-frame))
             (fp (frame-parameter wf 'alpha-background)))
        (if fp
            (unless (= 0 fp)
              (set-frame-parameter wf 'alpha-background (1- fp)))
          (set-frame-parameter wf 'alpha-background 99)))))

  (defun lmm/alpha-decrease()
    (interactive)
    (if-let* ((version (>= emacs-major-version 29))
              (wf (window-frame))
              (fp (frame-parameter wf 'alpha-background)))
        (unless (= 100 fp)
          (set-frame-parameter wf 'alpha-background (1+ fp)))))

  (defun lmm/fully-transparent()
    (interactive)
     (set-frame-parameter (window-frame) 'alpha-background 0))

  (defun lmm/fully-opaque()
    (interactive)
     (set-frame-parameter (window-frame) 'alpha-background 100))

  (defhydra lmm/hydra-set-alpha(:foreign-keys warn :hint nil)
      ;; 增加透明度
      ("k" lmm/alpha-increase "Alpha Scale Increase")
      ;; 减小透明度
      ("j" lmm/alpha-decrease "Alpha Scale Decrease")
      ("0" lmm/fully-transparent "Fully Transparent")
      ("1" lmm/fully-opaque "Fully Opaque")
      ("q" nil "Quit ! ! !"))
#+END_SRC

* EVIL MODE
** Evil Core
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :straight t
    :init
    (add-hook 'after-init-hook 'evil-mode)
    ;;
    (setq evil-want-integration t
          ;; 在其他模式加载vim默认键绑定
          evil-want-keybinding nil
          evil-vsplit-window-right t
          evil-split-window-below t
          evil-want-C-u-delete t
          evil-want-C-u-scroll t
          evil-want-C-w-delete t
          evil-want-C-i-jump t
          evil-want-Y-yank-to-eol t
          ;; undo-tree时会出现未知卡顿
          evil-undo-system 'undo-redo
          ;; 禁止在 ex 命令当中补全 emacs 命令
          evil-ex-complete-emacs-commands nil
          ;; 使用 emacs 本身的撤销模式
          evil-want-fine-undo t
          ;; 粘贴替换选中文本不加入 kill ring 中
          evil-kill-on-visual-paste nil
          evil-echo-state nil
          evil-search-module 'evil-search
          evil-visual-char-tag (propertize "󰒅" 'face '(:foreground "cyan"))
          evil-normal-state-tag (propertize "󰇴" 'face '(:foreground "cyan"))
          evil-insert-state-tag (propertize "" 'face '(:foreground "cyan"))
          evil-visual-line-tag (propertize "󰉡" 'face '(:foreground "cyan"))
          evil-visual-block-tag (propertize "󰣟" 'face '(:foreground "cyan"))
          evil-motion-state-tag (propertize "󱙝" 'face '(:foreground "cyan"))
          evil-emacs-state-tag (propertize "" 'face '(:foreground "cyan"))
          evil-operator-state-tag (propertize "󱓁" 'face '(:foreground "cyan"))
          evil-replace-state-tag (propertize "󰉼" 'face '(:foreground "cyan"))
          evil-visual-screen-line-tag (propertize "󰒆" 'face '(:foreground "cyan")))

    :config
    (setq evil-goto-definition-functions '(evil-goto-definition-xref
                                           evil-goto-definition-imenu
                                           evil-goto-definition-semantic
                                           evil-goto-definition-search))
    (evil-set-command-property 'evil-upcase :move-point nil)

    (dolist (map '(evil-eval-map
                   evil-ex-search-keymap
                   evil-ex-completion-map))
      (define-keymap
        :keymap (symbol-value map)
        "C-a" 'beginning-of-line
        "C-b" 'backward-char
        "C-c" 'abort-recursive-edit
        "C-d" 'delete-char
        "C-f" 'forward-char
        "C-k" 'kill-line
        "C-v" 'evil-ex-command-window
        "M-n" 'next-complete-history-element
        "M-p" 'previous-complete-history-element))
    (defun backward-symbol (count)
      "Move point to the previous position that is the start of a symbol.
  A symbol is any sequence of characters that are in either the
  word constituent or symbol constituent syntax class.
  With prefix argument ARG, do it ARG times if positive, or move
  forwards ARG times if negative.
  "
      (interactive "p")
      (forward-symbol (- 0 (or count 1))))

    (evil-define-key* 'insert 'global
      "j" (+key-dispath-command-def +evil-key-dispath-j 'self-insert-command 0.2 'after-char
                                       "k" 'evil-normal-state
                                       "l" 'toggle-input-method
                                       "w" 'forward-symbol
                                       "b" 'backward-symbol
                                       ))

    (setq evil-emacs-state-modes nil)
    (setq evil-insert-state-modes nil)
    (setq evil-motion-state-modes nil)

    (setq evil-visual-state-cursor 'hollow)
    (setq evil-normal-state-cursor '(box "cyan"))
    ;;清空插入模式的按键
    ;; (setcdr evil-insert-state-map nil)
    ;; 定制ex命令
    (evil-ex-define-cmd "q" 'kill-this-buffer)
    ;; (evil-set-leader 'normal (kbd "<SPC>"))

    (general-create-definer lmm/evil-space-leader-def
      :states '(normal motion insert)
      :keymaps 'override
      :prefix-command 'lmm/evil-space-leader-def-command
      :prefix-map 'lmm/evil-space-leader-def-map
      :non-normal-prefix "C-SPC"
      :prefix "SPC")

    (defun lmm/SPC-SPC()
      "Select active minibuffer window, or call execute-extended-command if nil"
      (interactive)
      (if-let (window (active-minibuffer-window))
          (select-window window)
          (setq this-command 'execute-extended-command)
        (call-interactively #'execute-extended-command)))

    (lmm/evil-space-leader-def
      ;; "w" evil-window-map
      "," 'switch-to-buffer
      "<" 'switch-to-buffer
      "si" 'imenu
      "ff" 'find-file
      "fb" 'switch-to-buffer
      "fr" 'recentf-open-files
      "fw" 'save-buffer
      "fs" 'save-buffer
      "fp" 'lmm/open-config-file
      "fn" 'evil-buffer-new
      "qq" 'lmm/delete-frame-or-C-x-C-c
      "qs" 'evil-save-and-quit
      "es" 'eval-last-sexp
      "ed" 'eval-defun
      "er" 'eval-region
      "eb" 'eval-buffer
      "ep" 'eval-print-last-sexp
      "bk" 'kill-current-buffer
      "'" 'evil-avy-goto-char-timer
      "SPC" 'lmm/SPC-SPC
      ":" 'eval-expression)
    (defhydra hydra-Ctrl-quick-key(:foreign-keys warn
                                                 :hint nil)
      ("d" evil-scroll-down)
      ("u" evil-scroll-up)
      ("f" evil-scroll-page-down)
      ("b" evil-scroll-page-up)
      ("j" evil-next-line)
      ("k" evil-previous-line)
      ("q" nil "Quit"))

    (evil-define-key '(normal motion) 'global
      "q" #'evil-execute-macro
      "Q" #'evil-record-macro
      "'" #'evil-goto-mark
      "`" #'evil-goto-mark-line
      "U" #'evil-redo
      "," #'evil-window-map
      "t" #'repeat
      "z/" #'evil-ex-nohighlight
      "z." #'evil-toggle-fold
      )
    (evil-define-key '(normal motion visual) 'global
      "gh" #'evil-first-non-blank
      "H" #'evil-first-non-blank
      "gl" #'evil-last-non-blank
      "L" #'evil-last-non-blank
      "f" 'evil-avy-goto-word-1
      "F" 'evil-avy-goto-char)

    (defun +open-new-line-down(count)
      (interactive "p")
      (end-of-line)
      (newline count)
      (indent-for-tab-command))
    (defun +open-new-line-up(count)
      (interactive "p")
      (beginning-of-line)
      (newline count)
      (forward-line -1)
      (indent-for-tab-command))
    (defun +beginning-of-line-or-text-line()
      (interactive)
      (if (bolp)
          (beginning-of-line-text)
        (beginning-of-visual-line)))
    :bind
    (:map evil-insert-state-map
          ("C-a" . +beginning-of-line-or-text-line)
          ("C-e" . end-of-visual-line)
          ("C-d" . evil-delete-char)
          ("C-k" . kill-line)
          ("C-p" . previous-line)
          ("C-n" . next-line)
          ("C-g" . evil-normal-state)
          ("C-y" . yank)
          ("C-<return>" . +open-new-line-down)
          ("M-<return>" . +open-new-line-up)
          :map evil-window-map
          ("d" . kill-buffer-and-window)
          ("x" . kill-current-buffer)
          ("n" . evil-buffer-new)
          ("p" . evil-prev-buffer)
          ("w" . nil)
          ("W" . evil-window-next)
          ("C-h" . nil)
          ("." . evil-switch-to-windows-last-buffer)))
#+END_SRC

** Other Evil Plugins
#+BEGIN_SRC emacs-lisp
  ;; 更多的按键绑定
  (use-package evil-collection
    :straight t
    :config
    (dolist (mode '(corfu))
      (delq mode evil-collection-mode-list))
    :hook
    (evil-mode-hook . evil-collection-init))

  ;; 注释
  (use-package evil-nerd-commenter
    :straight t
    :after evil
    ;; :bind
    ;; (:map lmm/leader-comma-map
    ;;       (";" . evilnc-comment-operator)
    ;;       ("l" . evilnc-comment-or-uncomment-lines))
    :config
    (defun lmm/comment-dwim-auto-insert (arg)
      "comment line or mark region, if evil normal state auto toggle insert state"
      (interactive "*P")
      (comment-dwim arg)
      (if evil-normal-state-minor-mode
          (evil-append 0)))

    (general-define-key
     :states 'normal
     "M-;" 'comment-dwim)

    (general-define-key
     :states 'normal
     "gc" #'evilnc-comment-operator)

    (define-key evil-inner-text-objects-map "c" #'evilnc-inner-comment)
    (define-key evil-outer-text-objects-map "c" #'evilnc-outer-comment))

  ;; 括号修改
  (use-package evil-surround
    :straight t
    :hook
    (org-mode-hook . evil-surround-mode)
    (prog-mode-hook . evil-surround-mode)
    (conf-mode-hook . evil-surround-mode))

  ;; 撤销树
  (use-package undo-tree
    :disabled
    ;; :straight t
    ;; :hook
    ;; (evil-mode-hook . global-undo-tree-mode)
    :bind
    (:map undo-tree-visualizer-mode-map
          ("l" . undo-tree-visualize-switch-branch-right)
          ("h" . undo-tree-visualize-switch-branch-left)
          :map undo-tree-map
          ("C-/" . evil-undo)))
  ;; C-x u 会出来一个撤销树可供选择以前的一些编辑状态
  ;; 可按 d 进行 diff 对比

  ;; 交换标记区域
  (use-package evil-exchange
    :straight t
    :after evil
    :config
    (general-define-key
     :states 'normal
     "gx" 'evil-exchange
     "gX" 'evil-exchange-cancel))

  ;; 参数跳转与修改
  (use-package evil-args
    :straight t
    :after evil
    :bind
    (:map evil-inner-text-objects-map
          ("a" . evil-inner-arg)
          :map evil-outer-text-objects-map
          ("a" . evil-outer-arg)
          :map evil-normal-state-map
          ("[a" . evil-backward-arg)
          ("]a" . evil-forward-arg)
          :map evil-motion-state-map
          ("[a" . evil-backward-arg)
          ("]a" . evil-forward-arg)
          )
    )

  ;; 快速跳转
  (use-package evil-snipe
    :disabled
    :straight nil
    :hook
    (evil-mode-hook . evil-snipe-mode)
    :init
    (setq evil-snipe-scope 'visible
          evil-snipe-repeat-scope 'nil
          evil-snipe-smart-case t)
    :config
    (evil-define-key '(normal motion visual) 'global
      "f" #'evil-snipe-f
      "F" #'evil-snipe-F
      "s" #'evil-snipe-s
      "S" #'evil-snipe-S)
    (set-face-attribute 'evil-snipe-matches-face nil
                        :background "unspecified"
                        :foreground "red"
                        :weight 'normal
                        :underline '(:color "red" :position 0))
    (set-face-attribute 'evil-snipe-first-match-face nil
                        :background "unspecified"
                        :foreground nil
                        :underline nil
                        :weight 'normal))

  (use-package evil-embrace
    :straight t
    :after evil-snipe
    :init
    (setq evil-embrace-show-help-p nil)
    :config
    (evil-embrace-enable-evil-surround-integration))
  #+END_SRC

** Other Evil EditUtils
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :config
    ;; fix built in evil-yank.
    (evil-define-operator evil-yank (beg end type register yank-handler)
    "Save the characters in motion into the kill-ring."
    :move-point nil
    :repeat nil
    (interactive "<R><x><y>")
    (let ((evil-was-yanked-without-register
           (and evil-was-yanked-without-register (not register))))
      (cond
       ((and (fboundp 'cua--global-mark-active)
             (fboundp 'cua-copy-region-to-global-mark)
             (cua--global-mark-active))
        (cua-copy-region-to-global-mark beg end))
       ((eq type 'block)
        (evil-yank-rectangle beg end register yank-handler))
       ((memq type '(line screen-line))
        (evil-yank-lines beg end register yank-handler))
       (t
        (evil-yank-characters beg end register yank-handler)
        ))))

    (evil-define-command lmm/evil-vsplit-next-buffer (&optional count)
      "Vsplits the window and goes to the COUNT-th next buffer in the buffer list."
      :repeat nil
      (interactive "p")
      (evil-window-vsplit)
      (evil-next-buffer count))

    (evil-define-command lmm/evil-vsplit-prev-buffer (&optional count)
      "Vsplits window and goes to the COUNT-th prev buffer in the buffer list."
      :repeat nil
      (interactive "p")
      (evil-window-vsplit)
      (evil-prev-buffer count))

    ;; 删除当前行光标前空格，保留一个
    (evil-define-text-object lmm/evil-inner-space (count &optional beg end type)
      "Select in space."
      (let* ((point (point))
             (begin (+ point (skip-chars-backward " \t")))
             (end (+ begin (skip-chars-forward " \t"))))
        (if (= begin end)
            (error "Not found space!")
          (evil-range (1+ begin) end))))

    ;; 删除当前行光标前所有空格
    (evil-define-text-object lmm/evil-outer-space (count &optional beg end type)
      "Select outer space."
      (let* ((point (point))
             (begin (+ point (skip-chars-backward " \t")))
             (end (+ begin (skip-chars-forward " \t"))))
        (if (= begin end)
            (error "Not found space!")
          (evil-range begin end))))

    (define-key evil-inner-text-objects-map " " 'lmm/evil-inner-space)
    (define-key evil-outer-text-objects-map " " 'lmm/evil-outer-space)

    (evil-define-operator lmm/evil-replace-paste (beg end)
      "Select and replace from kill ring"
      (when-let ((text (current-kill 0)))
        (delete-region beg end)
        (insert-for-yank text)))

    (evil-define-key 'normal 'global
      "R" 'lmm/evil-replace-paste)

    (evil-define-text-object lmm/evil-inner-line (count &optional beg end type)
      "Select in current line, only have text"
      (let ((begin (save-excursion (beginning-of-line-text) (point)))
            (end (pos-eol)))
        (evil-range begin end)))

    (evil-define-text-object lmm/evil-a-line (count &optional beg end type)
      "Select in current line"
      (evil-range (pos-bol) (pos-eol)))

    (define-key evil-inner-text-objects-map "l" 'lmm/evil-inner-line)
    (define-key evil-outer-text-objects-map "l" 'lmm/evil-a-line)

    (evil-define-motion lmm/evil-forward-in-word-begin(count &optional bigword)
      "Jump to next word"
      :type excessive
      (forward-to-word (or count 1)))

    ;; (evil-define-key '(normal motion) 'global
    ;;   "w" 'lmm/evil-forward-in-word-begin)

    (evil-define-motion lmm/evil-forward-WORD-end (count)
      "Move the cursor to the end of the COUNT-th next WORD."
      :type inclusive
      (let ((thing 'symbol)
            (count (or count 1)))
        (evil-signal-at-bob-or-eob count)
        ;; Evil special behaviour: e or E on a one-character word in
        ;; operator state does not move point
        (unless (and (evil-operator-state-p)
                     (= 1 count)
                     (let ((bnd (bounds-of-thing-at-point 'symbol)))
                       (and bnd
                            (= (car bnd) (point))
                            (= (cdr bnd) (1+ (point)))))
                     (looking-at "[[:word:]]"))
          (evil-forward-end thing count))))

    (evil-define-key* '(normal motion visual) 'global
      "E" #'lmm/evil-forward-WORD-end)

    (evil-define-motion lmm/evil-backward-in-word-begin(count &optional bigword)
      "Backward in word begin"
      :type exclusive
      (backward-word (or count 1)))

    ;; (evil-define-key '(normal motion) 'global
    ;;   "r" 'lmm/evil-backward-in-word-begin)

    (evil-define-operator lmm/evil-narrow-region(beg end)
      "Narrow selected region."
      :repeat nil
      (narrow-to-region beg end))

    (evil-define-command lmm/evil-narrow()
      "Restrict editing in this buffer to the current region.
  if `buffer-narrowed-p' return non-nil, call interactive `widen'"
      :repeat nil
      (interactive)
      (if (buffer-narrowed-p)
          (call-interactively 'widen)
        (call-interactively 'lmm/evil-narrow-region)))

    (evil-define-key* 'normal 'global "zn" #'lmm/evil-narrow)
    )
#+END_SRC

* WINDOW AND BUFFER AND FRAME
** Utils Functions
#+BEGIN_SRC emacs-lisp
  (defun lmm/kill-current-buffer-and-window ()
    "kill current buffer and window, if just one window, kill current buffer"
    (interactive)
    (if (and (window-full-width-p) (window-full-height-p))
        (kill-current-buffer)
      (kill-buffer-and-window)))

  (defun lmm/split-window-right (&optional arg)
    "VSplit this window"
    (interactive "P")
    (split-window-right)
    (let ((target-window (next-window)))
      (set-window-buffer target-window (other-buffer))
      (unless arg
        (select-window target-window))))

  (defun lmm/split-window-below (&optional arg)
    "Split this window"
    (interactive "P")
    (split-window-below)
    (let ((target-window (next-window)))
      (set-window-buffer target-window (other-buffer))
      (unless arg
        (select-window target-window))))

  (defun lmm/split-window-right-select-buffer(&optional arg)
    "VSplit this buffer, switch to select buffer"
    (interactive "P")
    (if-let ((buffer (read-buffer-to-switch "Switch to Buffer: ")))
        (let ((target-window (split-window-right)))
          (set-window-buffer target-window buffer)
          (unless arg
            (select-window target-window)))))

  (defun lmm/split-window-below-select-buffer(&optional arg)
    "Split this buffer, switch to select buffer"
    (interactive "P")
    (if-let ((buffer (read-buffer-to-switch "Switch to Buffer: ")))
        (let ((target-window (split-window-below)))
          (set-window-buffer target-window buffer)
          (unless arg
            (select-window target-window)))))

  (general-define-key
   :keymaps 'evil-window-map
   "s" 'lmm/split-window-below
   "v" 'lmm/split-window-right
   "S" 'lmm/split-window-below-select-buffer
   "V" 'lmm/split-window-right-select-buffer)

  (use-package evil
    :bind
    (:map evil-window-map
          ("D" . kill-this-buffer)
          ("d" . lmm/kill-current-buffer-and-window)))
#+END_SRC

** Window Split Config
#+BEGIN_SRC emacs-lisp
  ;; 窗口布局历史切换
  (use-package winner
    :after evil
    :config
    (winner-mode)
    (define-key evil-window-map "u" 'winner-undo)
    (define-key evil-window-map "U" 'winner-redo))

  ;; 尽可能重用现有buffer
  ;; (customize-set-variable 'display-buffer-base-action
  ;;                         '((display-buffer-reuse-window display-buffer-same-window)
  ;;                           (reusable-frames . t)))
  ;; (customize-set-variable 'even-window-sizes nil)

  ;; (add-to-list
  ;;  'display-buffer-alist
  ;;  '("^\\*\\(Help\\|info\\|cargo.*\\)\\*$" (display-buffer-at-bottom) (window-height . 0.4)))
  (add-to-list
   'display-buffer-alist
   '("^\\*.*\\*$" (display-buffer-at-bottom) (window-height . 0.4)))
  (add-to-list
   'display-buffer-alist
   '("^\\*Org Src.*\\*$" (display-buffer-same-window)))
#+END_SRC

** Window Jump Config
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :straight t
    :init
    (setq aw-background nil)
    :hook
    (after-init-hook . ace-window-display-mode)
    :config

    (defmacro +ace-auto-select-window (key)
      "Define ace select window function, KEY is a char."
      (let ((funname (intern (format "+ace-select-window-%s" (char-to-string key)))))
        `(progn (defun ,funname (arg)
                  ,(format   "Select a window %s.
  Perform an action based on ARG described below.

  By default, behaves like extended `other-window'.
  See `aw-scope' which extends it to work with frames.

  Prefixed with one \\[universal-argument], does a swap between the
  selected window and the current window, so that the selected
  buffer moves to current window (and current buffer moves to
  selected window).

  Prefixed with two \\[universal-argument]'s, deletes the selected
  window."(char-to-string key))
                  (interactive "p")
                  (when (> (count-windows) 2)
                    (setq unread-command-events
                          (append unread-command-events
                                  (list ,key))))
                  (ace-window arg))
                ',funname)))

    (general-define-key
     :keymaps 'evil-window-map
     "," 'evil-window-mru
     "w s" 'ace-swap-window
     "D" 'ace-delete-window
     "O" 'ace-delete-other-windows
     "1" (+ace-auto-select-window ?1)
     "2" (+ace-auto-select-window ?2)
     "3" (+ace-auto-select-window ?3)
     "4" (+ace-auto-select-window ?4)
     "5" (+ace-auto-select-window ?5)
     "6" (+ace-auto-select-window ?6)
     "7" (+ace-auto-select-window ?7)
     "8" (+ace-auto-select-window ?8)
     "9" (+ace-auto-select-window ?9)
     ))

  (global-set-key (kbd "C-M-j") #'scroll-other-window)
  (global-set-key (kbd "C-M-k") #'scroll-other-window-down)
#+END_SRC

** Buffers Config
#+BEGIN_SRC emacs-lisp
  (use-package ibuffer
    :defer t
    :init
    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 22 22 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 12 12 :left :elide)
                  " "
                  vc-relative-file)
            (mark modified read-only vc-status-mini " "
                  (name 22 22 :left :elide)
                  " "
                  (size-h 9 -1 :right)
                  " "
                  (mode 14 14 :left :elide)
                  " "
                  (vc-status 12 12 :left)
                  " "
                  vc-relative-file)))

    (setq ibuffer-filter-group-name-face 'font-lock-doc-face)
    :config
    (global-set-key [remap list-buffers] 'ibuffer)
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (file-size-human-readable (buffer-size)))
    )
  (use-package ibuffer-vc
    :straight t
    :config
    (defun ibuffer-set-up-preferred-filters ()
      (ibuffer-vc-set-filter-groups-by-vc-root)
      (unless (eq ibuffer-sorting-mode 'filename/process)
        (ibuffer-do-sort-by-filename/process)))

    (add-hook 'ibuffer-hook 'ibuffer-set-up-preferred-filters)

    (setq-default ibuffer-show-empty-filter-groups nil)
    )
#+END_SRC

** Frame Config
#+BEGIN_SRC emacs-lisp
  (defun lmm/delete-frame-or-C-x-C-c(&optional arg)
    (interactive "P")
    (cond (server-buffer-clients
           (server-edit arg))
          ((delete-frame-enabled-p)
           (delete-frame))
          (t
           (save-buffers-kill-terminal arg))))
#+END_SRC

** Auto Save Window Size
保存工作区
#+BEGIN_SRC emacs-lisp
  (use-package desktop
    :defer t
    :init
    (setq desktop-auto-save-timeout 600))
#+END_SRC

* MINIBUFFER
** Minibuffer
#+BEGIN_SRC emacs-lisp
  ;; 在 minibuffer 中执行 minibuffer
  (setq enable-recursive-minibuffers t)
  ;; 禁止光标移动到提示文本上
  (customize-set-variable 'minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt))

  (define-key minibuffer-local-map (kbd "C-w") #'backward-kill-word)

  (defun lmm/evil-minibuffer-insert()
    "Minibuffer evil insert state"
    (setq-local evil-echo-state nil)
    (evil-insert 1))

  (remove-hook 'minibuffer-setup-hook 'evil-collection-minibuffer-insert)
  ;; (add-hook 'minibuffer-setup-hook 'lmm/evil-minibuffer-insert)


  (use-package evil
    :config
    (evil-define-key* 'normal minibuffer-local-map
      (kbd "ESC") 'minibuffer-keyboard-quit
      (kbd "q") 'minibuffer-keyboard-quit
      (kbd "C-f") 'scroll-up-command
      (kbd "C-b") 'scroll-down-command
      (kbd "C-v") 'scroll-up-command
      (kbd "C-d") 'scroll-up-command
      (kbd "C-u") 'scroll-down-command
      (kbd "C-p") #'previous-history-element
      (kbd "C-n") #'next-history-element
      (kbd "j") 'next-line
      (kbd "k") 'previous-line
      (kbd "J") 'next-history-element
      (kbd "K") 'previous-history-element
      (kbd "RET") 'exit-minibuffer
      (kbd "g") 'minibuffer-beginning-of-buffer
      (kbd "G") 'end-of-buffer
      (kbd "o") 'embark-act
      (kbd ",") #'previous-history-element
      (kbd ".") #'next-history-element
      )
    (evil-define-key* 'insert minibuffer-local-map
      (kbd "ESC") #'minibuffer-keyboard-quit
      (kbd "C-g") #'minibuffer-keyboard-quit
      (kbd "C-v") #'scroll-up-command
      (kbd "C-n") #'next-line
      (kbd "C-p") #'previous-line
      (kbd "C-k") #'kill-line
      (kbd "RET") #'exit-minibuffer
      )

    (general-define-key
     :states 'insert
     :keymaps 'minibuffer-local-map
     "j" (general-key-dispatch 'self-insert-command
           :timeout 0.1
           "k" 'evil-normal-state
           ";" 'minibuffer-keyboard-quit)))
#+END_SRC

** Vertico -- 命令完成
#+BEGIN_SRC emacs-lisp
  ;; minibuffer命令记录数量
  (setq-default history-length 1000)
  ;;命令历史
  (use-package savehist
    :config
    (add-to-list 'savehist-additional-variables 'url-proxy-services)
    (add-to-list 'savehist-additional-variables '(kill-ring . 50))
    :hook
    (after-init-hook . savehist-mode))
  (use-package vertico  ;;命令补全
    :straight (:files (:defaults "extensions/*"))
    :init
    (setq vertico-count 15)
    :hook
    (after-init-hook . vertico-mode)
    (minibuffer-setup-hook . vertico-repeat-save)
    :bind
    (:map vertico-map
          ("C-w" . backward-kill-word)
          ("C-r" . consult-history)
          ("C-<return>" . vertico-exit-input)
          ("C-h" . vertico-directory-delete-char)
          ("C-w" . vertico-directory-delete-word)
          ("M-<backspace>" . vertico-directory-up)
          ("M-h" . vertico-directory-up)
          ("C-<backspace>" . backward-kill-word)
          ("C-u" . evil-delete-back-to-indentation))
    :config
    (lmm/evil-space-leader-def
      "x" #'vertico-repeat
      "X" #'vertico-repeat-select))
  (use-package orderless  ;;搜索排序
    :straight t
    :after vertico
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion))))
    :config
    (set-face-background 'orderless-match-face-0 "unspecified")
    (set-face-background 'orderless-match-face-1 "unspecified")
    (set-face-background 'orderless-match-face-2 "unspecified")
    (set-face-background 'orderless-match-face-3 "unspecified")
    )
  (use-package marginalia  ;;命令注释
    :straight t
    :after vertico
    :config
    (marginalia-mode)
    )
#+END_SRC

** Consult -- 搜索完成
#+BEGIN_SRC emacs-lisp
  (use-package consult
    :straight t
    :after vertico
    :config
    (global-set-key (kbd "M-Y") 'consult-yank-from-kill-ring)
    (global-set-key [remap switch-to-buffer] 'consult-buffer)
    (global-set-key [remap switch-to-buffer-other-window] 'consult-buffer-other-window)
    (global-set-key [remap switch-to-buffer-other-frame] 'consult-buffer-other-frame)
    (global-set-key [remap goto-line] 'consult-goto-line)
    (consult-customize
     consult-ripgrep consult-git-grep consult-grep
     consult-theme
     consult-bookmark consult-recent-file consult-xref
     consult--source-recent-file consult--source-project-recent-file consult--source-bookmark
     :preview-key "M-.")
    ;; 替换系统完成
    (setq completion-in-region-function
          (lambda (&rest args)
            (apply (if vertico-mode
                       #'consult-completion-in-region
                     #'completion--in-region)
                   args)))
    (setq consult-narrow-key (kbd "<"))
    (setq consult-find-args "find . -not ( -wholename */.* -prune -o -name node_modules -prune )")
    (set-face-attribute 'consult-preview-line nil
                        :foreground "#1E2029"
                        :background "#61bfff"
                        :extend nil)
    (defun lmm/consult-symbol-at-point (&optional n)
      "get symbol at current point, search geted symbol at consult-line"
      (interactive)
      (consult-line (thing-at-point 'symbol)))
    (defun lmm/consult-symbol-at-point-multi (&optional n)
      "get symbol at current point, search geted symbol at consult-line-multi"
      (interactive)
      (consult-line-multi nil (thing-at-point 'symbol)))

    (defun lmm/consult-word-at-point (&optional n)
      "get word at current point, search geted word at consult-line"
      (interactive)
      (consult-line (thing-at-point 'word)))
    (defun lmm/consult-word-at-point-multi (&optional n)
      "get word at current point, search geted word at consult-line-multi"
      (interactive)
      (consult-line-multi nil (thing-at-point 'word)))

    (defun lmm/consult-number-at-point (&optional n)
      "get number at current point, search geted number at consult-line"
      (interactive)
      (consult-line (if-let ((n (number-at-point)))
                        (number-to-string n)
                      nil)))
    (defun lmm/consult-number-at-point-multi (&optional n)
      "get number at current point, search geted number at consult-line-multi"
      (interactive)
      (consult-line-multi nil (if-let ((n (number-at-point)))
                                  (number-to-string n)
                                nil)))

    (defun consult-ripgrep-up-directory ()
      "restart current consult-ripgrep search in the parent directory"
      (interactive)
      (let ((parent-dir (file-name-directory (directory-file-name default-directory))))
        (when parent-dir
          (run-at-time 0 nil
                       #'consult-ripgrep
                       parent-dir
                       (ignore-errors
                         (buffer-substring-no-properties
                          (1+ (minibuffer-prompt-end)) (point-max))))))
      (minibuffer-quit-recursive-edit))

    (when (featurep 'evil)
      (evil-define-operator lmm/evil-consult(beg end)
        "Consult select region"
        :repeat nil
        (setq this-command 'consult-line)
        (consult-line
         (buffer-substring-no-properties beg end)))
      (evil-define-key* '(normal motion) 'global "gs" #'lmm/evil-consult))

    (when (featurep 'ace-window)
      (defun +consult-ace-switch-buffer-other-window ()
        "Switch buffer in other window."
        (interactive)
        (when-let ((window (aw-select nil)))
          (save-selected-window
            (aw-switch-to-window window)
            (setq this-command 'consult-buffer)
            (command-execute 'consult-buffer))))
      (define-key evil-window-map "B" #'+consult-ace-switch-buffer-other-window))

    (defmacro +consult-split-window-defun (side)
      "Define split window function, call `consult-buffer' to select buffer.
  SIDE can be up, down, left, right. If argume is non-nil, the newly created window is not selected"
      (let ((direction (if (eq (car side) 'quote)
                           (cadr side)
                         side)))
        `(defun ,(intern (format "+consult-split-window-%S" direction))(&optional arg)
           ,(format "Split this window %S" direction)
           (interactive "P")
           (let* ((old-window (selected-window))
                  (new-window (split-window nil nil ',direction))
                  selected)
             (unwind-protect
                 (let ((this-command 'consult-buffer))
                   (select-window new-window 'norecord)
                   (command-execute 'consult-buffer)
                   (setq selected t))
               (if selected
                   (and arg (select-window old-window 'norecord))
                 (and (select-window old-window 'norecord)
                      (delete-window new-window))))))))

    (define-keymap
      :keymap evil-window-map
      "w h" (+consult-split-window-defun 'left)
      "w l" (+consult-split-window-defun 'right)
      "w j" (+consult-split-window-defun 'down)
      "w k" (+consult-split-window-defun 'up)
      "V" #'+consult-split-window-right
      "S" #'+consult-split-window-down)

    (lmm/evil-space-leader-def
      "sb" 'consult-line
      "sB" 'consult-line-multi
      "/" 'consult-line
      "?" 'consult-line-multi
      "sf" 'consult-focus-lines
      "sd" 'consult-find
      "sF" 'consult-find
      "s.s" 'lmm/consult-symbol-at-point
      "s.S" 'lmm/consult-symbol-at-point-multi
      "s.w" 'lmm/consult-word-at-point
      "s.W" 'lmm/consult-word-at-point-multi
      "s.n" 'lmm/consult-number-at-point
      "s.N" 'lmm/consult-number-at-point-multi
      "si" (defun +consult-imenu-or-org-heading ()
             (interactive)
             (if (eq major-mode 'org-mode)
                 (progn
                   (setq this-command 'consult-org-heading)
                   (call-interactively #'consult-org-heading))
               (setq this-command 'consult-imenu)
               (call-interactively #'consult-imenu)))
      "sI" 'consult-imenu-multi
      "fr" 'consult-recent-file
      "sr" 'consult-ripgrep
      )
    )
  (use-package consult-flycheck
    :straight t
    :after consult
    )
#+END_SRC

** Embark -- 上下文菜单
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :straight t
    :bind
    (("C-;" . embark-act)
     :map minibuffer-local-map
     ("C-." . +embark-act-more)
     ("C-;" . embark-act)
     ("C-t" . embark-become)
     ("C-," . embark-select)
     ;; 导出当前列表到额外buffer，然后执行各种操作
     ("C-c C-o" . embark-export)
     :map help-map
     ("b" . embark-bindings))
    :init
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    (defun +embark-act-more ()
      (interactive)
      (let ((embark-quit-after-action nil))
        (embark-act)))
    ;; embark menu with which key
    (defun embark-which-key-indicator ()
      "An embark indicator that displays keymaps using which-key.
  The which-key help message will show the type and value of the
  current target followed by an ellipsis if there are further
  targets."
      (lambda (&optional keymap targets prefix)
        (if (null keymap)
            (which-key--hide-popup-ignore-command)
          (which-key--show-keymap
           (if (eq (plist-get (car targets) :type) 'embark-become)
               "Become"
             (format "Act on %s '%s'%s"
                     (plist-get (car targets) :type)
                     (embark--truncate-target (plist-get (car targets) :target))
                     (if (cdr targets) "¡­" "")))
           (if prefix
               (pcase (lookup-key keymap prefix 'accept-default)
                 ((and (pred keymapp) km) km)
                 (_ (key-binding prefix 'accept-default)))
             keymap)
           nil nil t (lambda (binding)
                       (not (string-suffix-p "-argument" (cdr binding))))))))

    (setq embark-indicators
          '(embark-which-key-indicator
            embark-highlight-indicator
            embark-isearch-highlight-indicator))

    (defun embark-hide-which-key-indicator (fn &rest args)
      "Hide the which-key indicator immediately when using the completing-read prompter."
      (which-key--hide-popup-ignore-command)
      (let ((embark-indicators
             (remq #'embark-which-key-indicator embark-indicators)))
        (apply fn args)))

    (advice-add #'embark-completing-read-prompter
                :around #'embark-hide-which-key-indicator)


    (defvar-keymap embark-become-helpful-map
      :doc "Key map for embark become helpful."
      "x" 'execute-extended-command
      "f" 'helpful-callable
      "c" 'helpful-command
      "F" 'describe-face
      "v" 'helpful-variable
      "s" 'helpful-symbol
      "M" 'helpful-macro
      "m" 'woman
      "I" 'describe-input-method
      "i" 'info-display-manual)

    (add-to-list 'embark-become-keymaps 'embark-become-helpful-map)
    (define-key embark-file-map "s" 'lmm/sudo-find-file)
    )
  (use-package embark-consult
    :straight t
    :after (embark consult)
    :demand t
    :hook
    (embark-collect-mode . consult-preview-at-point-mode)
    :config

    (defmacro embark-consult-search-def(name &optional async up-d)
      `(defun ,(intern (if up-d
                           (format "+%S-up-directory"  name)
                         (format "+%S" name)))
           ,@(if async
                 '((&optional argu)
                   (interactive "P"))
               '(()(interactive)))
         (minibuffer-with-setup-hook
             (:append (lambda ()
                        (when-let ((contents (minibuffer-contents))
                                   (initial (consult--async-split-initial ""))
                                   (beg (minibuffer-prompt-end)))
                          ,(if async
                               `(unless (string-match-p (concat "^" initial) contents)
                                  (goto-char beg)
                                  (insert initial)
                                  (goto-char (point-max)))
                             `(when (string-match-p (concat "^" initial) contents)
                                (delete-region beg (+ (length initial) beg)))))))
           (setq this-command ',name)
           ,(cond (up-d
                   `(funcall-interactively ',name (file-name-directory (directory-file-name default-directory))))
                  (async
                   `(if argu
                        (funcall-interactively ',name (file-name-directory (directory-file-name default-directory)))
                      (command-execute ',name)))
                  (t
                   `(command-execute ',name))))))

    (defvar-keymap embark-consult-all-search-map
      :doc "Keymap for Consult all search commands"
      "o" 'consult-outline
      "h" 'consult-org-heading
      "a" 'consult-org-agenda
      "i" 'consult-imenu
      "I" 'consult-imenu-multi
      "l" 'consult-line
      "L" 'consult-line-multi
      "g" 'consult-grep
      "r" 'consult-ripgrep
      "G" 'consult-git-grep
      "f" 'consult-find
      "F" 'consult-locate
      "m" 'consult-man)

    (fset 'embark-consult-all-search-map embark-consult-all-search-map)

    (defvar-keymap embark-become-consult-search-map
      :doc "Key map for embark become consult search."
      :parent embark-meta-map
      "c" 'embark-consult-all-search-map
      "C-u" 'universal-argument
      "r" (embark-consult-search-def consult-ripgrep t)
      "R" (embark-consult-search-def consult-ripgrep t t)
      "g" (embark-consult-search-def consult-grep t)
      "G" (embark-consult-search-def consult-grep t t)
      "f" (embark-consult-search-def consult-find t)
      "F" (embark-consult-search-def consult-find t t)
      "t" (embark-consult-search-def consult-git-grep t)
      "T" (embark-consult-search-def consult-git-grep t t)
      "m" (embark-consult-search-def consult-man t)
      "p" (embark-consult-search-def consult-locate t)
      "y" (embark-consult-search-def consult-yank-from-kill-ring)
      "l" (embark-consult-search-def consult-line)
      "L" (embark-consult-search-def consult-line-multi)
      "b" (embark-consult-search-def consult-line)
      "B" (embark-consult-search-def consult-line-multi)
      "i" (embark-consult-search-def consult-imenu)
      "I" (embark-consult-search-def consult-imenu-multi)
      "h" (embark-consult-search-def consult-org-heading)
      "o" (embark-consult-search-def consult-outline)
      "a" (embark-consult-search-def consult-org-agenda))

    (add-to-list 'embark-become-keymaps 'embark-become-consult-search-map)
    )
#+END_SRC

* ORG MODE CONFIG
#+BEGIN_SRC emacs-lisp
  (use-package org
    :straight (:type built-in)
    :defer t
    :init
    (setq org-src-window-setup 'plain
          org-src-tab-acts-natively nil
          org-imenu-depth 3

          ;; 启用todo层级关系
          org-enforce-todo-dependencies t
          ;; 添加完成时间
          org-log-done 'time
          ;; 任务完成时间记录放进抽屉, 默认为 "LOGBOOK"
          ;; org-log-into-drawer "TODOLOG"
          org-log-into-drawer t
          ;; 时钟记录抽屉, 默认为 "LOGBOOK"
          org-clock-into-drawer "CLOCKLOG"
          ;; capture file
          org-default-notes-file "~/.org/captures.org")

    (setq org-todo-keywords
          '((sequence "TODO(t)" "|" "DONE(d)")
            (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)")
            (sequence "|" "CANCELED(c)"))))

  (use-package org-agenda
    :after org
    :config
    ;; all agenda files.
    (dolist (path '("~/.org/EveryDayTODO.org"))
      (when (file-exists-p path)
        (add-to-list 'org-agenda-files path))))

  (use-package org-roam
    :disabled
    :straight t
    :init
    (setq org-roam-directory (file-truename "~/.org/org-roam/")
          org-roam-node-display-template (concat "${title:50} "
                                                 (propertize "${tags}" 'face 'org-tag))
          org-roam-capture-templates '(("d" "file name have time" plain "%?"
                                        :target
                                        (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+TITLE: ${title}\n#+DATE: %<<%F %A %T>>\n#+STARTUP: indent content\n")
                                        :unnarrowed t)
                                       ("n" "file name no time" plain "%?"
                                        :target
                                        (file+head "${slug}.org" "#+TITLE: ${title}\n#+DATE: %<<%F %A %T>>\n#+STARTUP: indent content\n")
                                        :unnarrowed t)
                                       ("t" "add TODO" entry "* TODO %?"
                                        :target
                                        (file+head "${slug}.org" "#+TITLE: ${title}\n#+DATE: %<<%F %A %T>>\n#+STARTUP: indent content\n")
                                        :unnarrowed t))
          org-roam-dailies-capture-templates '(("d" "default" entry "* %?"
                                                :target
                                                (file+head "%<%Y-%m-%d>.org" "#+TITLE: %<%Y-%m-%d>\n#+DATE: %<<%F %A %T>>\n#+STARTUP: indent content\n")
                                                :unnarrowed t
                                                )
                                               ("t" "todo" entry "* TODO %?"
                                                :target
                                                (file+head "%<%Y-%m-%d>.org" "#+TITLE: %<%Y-%m-%d>\n#+DATE: %<<%F %A %T>>\n#+STARTUP: indent content\n")
                                                :unnarrowed t)))
    (lmm/evil-space-leader-def
      "of" #'org-roam-node-find
      "oc" #'org-roam-capture
      "oo" #'org-open-at-point
      "oi" #'org-roam-node-insert
      "o." #'org-roam-dailies-goto-today
      )
    :commands org-roma
    )

  (use-package org-tempo
    :after org
    :config
    ;; copy from source file
    ;; (defun org-tempo-add-block (entry)
    ;;   "Add block entry from `org-structure-template-alist'."
    ;;   (let* ((key (format "<%s" (car entry)))
    ;;          (name (cdr entry))
    ;;          (special (member name '("SRC" "EXPORT"))))
    ;;     (tempo-define-template (format "org-%s" (replace-regexp-in-string " " "-" name))
    ;;                            `(,(format "#+BEGIN_%s%s" name (if special " " ""))
    ;;                              ,(when special 'p) '> n ,(unless special 'p) n
    ;;                              ,(format "#+END_%s" (car (split-string name " ")))
    ;;                              >)
    ;;                            key
    ;;                            (format "Insert a %s block" name)
    ;;                            'org-tempo-tags)))
    (setq org-structure-template-alist
          '(("a" . "EXPORT ascii")
            ("c" . "CENTER")
            ("C" . "COMMENT")
            ("e" . "EXAMPLE")
            ("E" . "EXPORT")
            ("h" . "EXPORT html")
            ("l" . "EXPORT latex")
            ("q" . "QUOTE")
            ("s" . "SRC")
            ("se" . "SRC emacs-lisp")
            ("spy" . "SRC python")
            ("sr" . "SRC rust")
            ("sc" . "SRC c")
            ("scc" . "SRC c++")
            ("sconf" . "SRC conf")
            ("ssh" . "SRC sh")
            ("v" . "VERSE")))
    (setq org-tempo-keywords-alist
          '(("L" . "latex")
            ("H" . "html")
            ("A" . "ascii")
            ("i" . "index")
            ("ti" . "TITLE")
            ("au" . "AUTHOR")
            ("stu" . "STARTUP")))
    )

  ;; (use-package org-superstar
  ;;   :straight t
  ;;   :hook
  ;;   (org-mode-hook . org-superstar-mode))

  (use-package org-modern
    :straight t
    :init
    (setq org-modern-block-name nil)
    (setq org-modern-block-fringe nil)
    :hook
    (org-mode-hook . org-modern-mode)
    (org-agenda-finalize-hook . org-modern-agenda))

  (use-package evil-org
    :disabled
    :straight t
    :hook
    (org-mode-hook . evil-org-mode))
#+END_SRC

* NOTES
#+BEGIN_SRC emacs-lisp
  (use-package denote
    :straight t
    :init
    (setq denote-directory "~/.notes")
    :bind
    (:map lmm/evil-space-leader-def-map
          ("nn" . denote)
          ("nc" . denote)
          ("nt" . denote-type)
          ("nf" . denote-open-or-create)
          ("no" . denote-link-find-file)
          ("ni" . denote-link))
    :config
    (set-face-attribute 'denote-faces-keywords nil :background "pink4"
                        :foreground "white")
    (set-face-foreground 'denote-faces-title "cyan")
    (set-face-attribute 'denote-faces-date nil :inherit 'shadow))
#+END_SRC

* EDIT
** Enable Narrow Commands -- 只对目标进行编辑
#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-defun  'disabled nil)
  (put 'narrow-to-page   'disabled nil)
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

** Default Coding System
#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
#+END_SRC

** Newline
#+BEGIN_SRC emacs-lisp
  (defun lmm/newline()
    (interactive)
    (if (nth 4 (syntax-ppss))
        (call-interactively 'comment-indent-new-line)
      (call-interactively 'newline)))

  (global-set-key (kbd "RET") #'lmm/newline)
#+END_SRC

** Repeat -- 重复命令
#+BEGIN_SRC emacs-lisp
  (use-package repeat
    :hook
    (after-init-hook . repeat-mode)
    :commands repeat
    :init
    (setq repeat-check-key nil)
    ;; (setq repeat-exit-key " ")
    (defvar lmmv/repeat-next-key "]")
    (defvar lmmv/repeat-prev-key "[")
    :config
    (defvar lmmv/avy-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map lmmv/repeat-next-key 'avy-next)
        (define-key map lmmv/repeat-prev-key 'avy-prev)
        map)
      "Avy jump repeat map")
    (put 'avy-next 'repeat-map 'lmmv/avy-repeat-map)
    (put 'avy-prev 'repeat-map 'lmmv/avy-repeat-map)

    (defvar lmmv/toggle-buffer-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map lmmv/repeat-next-key 'next-buffer)
        (define-key map lmmv/repeat-prev-key 'previous-buffer)
        map)
      "Next/Prev buffer repeat map")
    (put 'next-buffer 'repeat-map 'lmmv/toggle-buffer-repeat-map)
    (put 'previous-buffer 'repeat-map 'lmmv/toggle-buffer-repeat-map)

    (defvar lmmv/evil-scroll-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map lmmv/repeat-next-key 'evil-scroll-down)
        (define-key map lmmv/repeat-prev-key 'evil-scroll-up)
        map)
      "Evil scroll repeat map")
    (put 'evil-scroll-up 'repeat-map 'lmmv/evil-scroll-repeat-map)
    (put 'evil-scroll-down 'repeat-map 'lmmv/evil-scroll-repeat-map)

    (defvar lmmv/evil-scroll-page-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map lmmv/repeat-next-key 'evil-scroll-page-down)
        (define-key map lmmv/repeat-prev-key 'evil-scroll-page-up)
        map)
      "Evil scroll page repeat map")
    (put 'evil-scroll-page-up 'repeat-map 'lmmv/evil-scroll-page-repeat-map)
    (put 'evil-scroll-page-down 'repeat-map 'lmmv/evil-scroll-page-repeat-map)

    (defvar lmmv/evil-toggle-buffer-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map lmmv/repeat-next-key 'evil-next-buffer)
        (define-key map lmmv/repeat-prev-key 'evil-prev-buffer)
        map)
      "Evil next/prev buffer repeat map")
    (put 'evil-next-buffer 'repeat-map 'lmmv/evil-toggle-buffer-repeat-map)
    (put 'evil-prev-buffer 'repeat-map 'lmmv/evil-toggle-buffer-repeat-map)

    (defvar lmmv/diff-hl-hunk-repeat-map
      (let ((map (make-sparse-keymap)))
        (define-key map lmmv/repeat-next-key 'diff-hl-next-hunk)
        (define-key map lmmv/repeat-prev-key 'diff-hl-previous-hunk)
        map)
      "Diff-hl-mode repeat map")
    (put 'diff-hl-next-hunk 'repeat-map 'lmmv/diff-hl-hunk-repeat-map)
    (put 'diff-hl-previous-hunk 'repeat-map 'lmmv/diff-hl-hunk-repeat-map)

    (put 'undo 'repeat-map nil)
    )
#+END_SRC

** Search -- anzu
#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :straight t
    :hook
    (after-init-hook . global-anzu-mode))

  (use-package color-rg
    :straight (:host github
                     :repo "manateelazycat/color-rg"
                     :branch "master")
    :commands color-rg-search-input
    )
#+END_SRC

*** Evil-auzu
#+BEGIN_SRC emacs-lisp
  (use-package evil-anzu
    :straight t
    :after evil anzu
    )
#+END_SRC

** Chinese Input -- 中文输入
#+BEGIN_SRC emacs-lisp
  (use-package rime
    :straight t
    :defer t
    :init
    (setq default-input-method 'rime)
    (straight-use-package '(rime-ice
                            :build nil
                            :type git
                            :host github
                            :repo "iDvel/rime-ice"
                            :branch "main"))
    (setq rime-share-data-dir (straight--repos-dir "rime-ice"))
    :config
    (defvar +rime-evil-escape-bindings-alist `((?j . ((?k . ,(lambda ()
                                                               (evil-repeat-stop)
                                                               (evil-normal-state)))
                                                      (?l . toggle-input-method)))))
    (defun +rime-evil-escape-advice (orig-fun key)
      (if rime--preedit-overlay
          ;; if `rime--preedit-overlay' is non-nil, then we are editing something, do not abort
          (apply orig-fun (list key))
        (let ((keybinds (cdr (assq key +rime-evil-escape-bindings-alist))))
          (if keybinds
              (let ((evt (read-event nil nil 0.2))
                    command)
                (cond
                 ((setq command (cdr (assq evt keybinds)))
                  (funcall command))
                 ((null evt) (apply orig-fun (list key)))
                 (t
                  (apply orig-fun (list key))
                  (if (numberp evt)
                      (apply orig-fun (list evt))
                    (setq unread-command-events (append unread-command-events (list evt)))))))
            (apply orig-fun (list key))))))

    (advice-add 'rime-input-method :around #'+rime-evil-escape-advice)
  )
#+END_SRC

** Default Variable -- 系统默认变量
#+BEGIN_SRC emacs-lisp
  (setq-default
   create-lockfiles nil                   ;; 创建锁定文件以防止其他用户同时编辑 , just like #filename
   inhibit-compacting-font-caches t
   buffers-menu-max-size 30
   case-fold-search t
   column-number-mode t
   ediff-split-window-function 'split-window-horizontally
   ediff-window-setup-function 'ediff-setup-windows-plain
   ;; 禁用TAB代替空白缩进
   indent-tabs-mode nil
   make-backup-files nil
   mouse-yank-at-point t
   save-interprogram-paste-before-kill t
   scroll-preserve-screen-position 'always
   scroll-conservatively 1000
   set-mark-command-repeat-pop t
   tooltip-delay 1.5
   truncate-lines nil
   truncate-partial-width-windows nil
   ;; 行上下边距
   scroll-margin 0
   ;; 列左右边距
   visual-line-fringe-indicators '(nil right-curly-arrow)
   )
#+END_SRC

** Default Mode -- 系统默认模式
*** 自动加载文件
#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-auto-revert-mode)
  (setq global-auto-revert-non-file-buffers t
        auto-revert-verbose nil)
#+END_SRC

*** 长行文件性能缓解
#+BEGIN_SRC emacs-lisp
  (use-package so-long
    :hook
    (after-init-hook . global-so-long-mode))
#+END_SRC

*** 选中文字输入替换
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

*** 关闭自动生产的保存文件
#+BEGIN_SRC emacs-lisp
  (setq auto-save-default nil)
#+END_SRC

** Word Jump
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :straight t
    :after evil
    :init
    (setq avy-timeout-seconds 0.3)
    :config

    (defmacro lmm/avy-action-thing-def (thing &optional action avy-back-action avy-cmd)
      "THING: set to `bounds-of-thing-at-point' keywords or `evil'.
  AVY-JUMP-ACTION: avy jump command.
  ACTION: function or cut, copy, swap, kill, del, yank.
  if ACTION is function, need return cons region (beg . end)."
      (declare (debug t) (indent t))
      (let ((range-fun (cond ((functionp thing)
                              `(funcall ',thing))
                             ((eq thing 'evil)
                              `(evil-save-state
                                 (evil-change-state 'operator)
                                 (if-let* ((command (evil-read-motion))
                                           (motion (nth 0 command))
                                           (range (evil-motion-range motion (nth 1 command) (nth 2 command))))
                                     (cons (car range) (cadr range))
                                   (user-error "Motion Select Error. motion: %S. range: %S." motion range)
                                   nil)))
                             (t
                              `(bounds-of-thing-at-point ',(or thing 'word)))))
            (save-current-p (or (eq action 'swap) avy-back-action)))
        `(progn
           (defun ,(intern (format "lmm/avy-%S-%S" (or action "action") (or thing "thing"))) ()
             (interactive)
             (let* (goto-string
                    ,@(when save-current-p
                        '(back-string
                          back-beg
                          back-end
                          (back-point (point))))
                    (avy-action-oneshot
                     (lambda (res)
                       (funcall 'avy-action-goto res)
                       (let* ((range ,range-fun)
                              (beg (car range))
                              (end (cdr range)))
                         (when (and beg end)
                           (setq goto-string
                                 ,(if (and (functionp action) (not (commandp action)))
                                      `(funcall ',action beg end)
                                    '(buffer-substring-no-properties beg end)))
                           ,(cond ((commandp action)
                                   `(funcall-interactively ',action beg end))
                                  ((memq action '(cut del))
                                   `(unless buffer-read-only
                                      (delete-region beg end)))
                                  ((eq action 'swap)
                                   `(unless buffer-read-only
                                      (when (stringp back-string)
                                        (delete-region beg end)
                                        (goto-char beg)
                                        (insert back-string))))
                                  ((eq action 'kill)
                                   `(funcall-interactively 'kill-region beg end))
                                  ((eq action 'yank)
                                   `(funcall-interactively 'copy-region-as-kill beg end)))))))
                    (old-avy-resume (symbol-function 'avy-resume)))
               (unwind-protect
                   (save-excursion
                     (save-selected-window
                       ,(when save-current-p
                          `(let* ((range ,range-fun)
                                  (beg (car range))
                                  (end (cdr range)))
                             (if (and beg end)
                               (setq back-string (buffer-substring-no-properties beg end)
                                     back-beg beg
                                     back-end end)
                               (user-error "Not word at point."))))
                       (call-interactively ',(or avy-cmd 'avy-goto-char))))
                 ,(when save-current-p
                    `(let* ((offset (- (point) back-point))
                            (beg (+ offset back-beg))
                            (end (+ offset back-end)))
                       (goto-char beg)
                       ,(cond ((eq action 'swap)
                               `(delete-region beg end))
                              ((commandp avy-back-action)
                               `(funcall-interactively ',avy-back-action beg end))
                              ((functionp avy-back-action)
                               `(funcall ',avy-back-action beg end)))))
                 ,(when (memq action '(swap copy cut))
                    '(when (and (not buffer-read-only) (stringp goto-string))
                       (insert goto-string)))
                 (setf (symbol-function 'avy-resume)
                       old-avy-resume)))))))

    (defun avy-goto-ex-search ()
      "Jump to one of the current evil search candidates."
      (interactive)
      (run-at-time 0 nil (lambda ()
                           (if evil-ex-search-pattern
                               (avy-with avy-goto-ex-search
                                 (let ((avy-background nil)
                                       (avy-all-windows nil)
                                       (avy-case-fold-search case-fold-search)
                                       (evil-hl-p evil-ex-active-highlights-alist))
                                   (evil-ex-nohighlight)
                                   (prog1
                                       (avy-process
                                        (avy--regex-candidates (regexp-quote (car evil-ex-search-pattern))))
                                     (when evil-hl-p
                                       (evil-ex-search-activate-highlight evil-ex-search-pattern))
                                     nil)))
                             (user-error "No search pattern"))))
      (when (minibufferp)
        (call-interactively 'exit-minibuffer)))
    (evil-define-avy-motion avy-goto-ex-search inclusive)


    (evil-define-key* 'normal 'global
      "zic" (lmm/avy-action-thing-def evil evilnc-comment-operator)

      "zio" (lmm/avy-action-thing-def symbol copy)
      "ziw" (lmm/avy-action-thing-def word copy)
      "zif" (lmm/avy-action-thing-def defun copy)
      "ziv" (lmm/avy-action-thing-def evil copy)
      "zIo" (lmm/avy-action-thing-def symbol cut)
      "zIw" (lmm/avy-action-thing-def word cut)
      "zIf" (lmm/avy-action-thing-def defun cut)
      "zIv" (lmm/avy-action-thing-def evil cut)


      "zdo" (lmm/avy-action-thing-def symbol kill)
      "zdw" (lmm/avy-action-thing-def word kill)
      "zdf" (lmm/avy-action-thing-def defun kill)
      "zdv" (lmm/avy-action-thing-def evil kill)
      "zDo" (lmm/avy-action-thing-def symbol del)
      "zDw" (lmm/avy-action-thing-def word del)
      "zDf" (lmm/avy-action-thing-def defun del)
      "zDv" (lmm/avy-action-thing-def evil del)

      "zso" (lmm/avy-action-thing-def symbol swap)
      "zsw" (lmm/avy-action-thing-def word swap)
      "zsf" (lmm/avy-action-thing-def defun swap)
      "zsv" (lmm/avy-action-thing-def evil swap))

    (define-key evil-ex-search-keymap (kbd "C-.") #'evil-avy-goto-ex-search)

    (lmm/evil-space-leader-def
      "aml" 'avy-move-line
      "amr" 'avy-move-region
      "acl" 'avy-copy-line
      "acr" 'avy-copy-region
      "aw" 'avy-goto-word-0
      "akl" 'avy-kill-whole-line
      "akr" 'avy-kill-region
      "ayl" 'avy-kill-ring-save-whole-line
      "ayr" 'avy-kill-ring-save-region
      "a/" 'evil-avy-goto-ex-search
      "aS" 'avy-isearch
      "ar" 'avy-resume
      "ab" 'avy-pop-mark))
#+END_SRC

** Goto Last Change
#+BEGIN_SRC emacs-lisp
  (use-package goto-chg
    :straight t
    )
#+END_SRC

** Expand-region
智能选择区域
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :straight t
    :bind (:map evil-visual-state-map
                ("." . er/expand-region)
                ("C-." . er/contract-region)))
#+END_SRC

** Parenthes Settings
*** Pairs
#+BEGIN_SRC emacs-lisp
  ;; (when (fboundp 'electric-pair-mode)
  ;;   (add-hook 'after-init-hook 'electric-pair-mode))
  (use-package paredit
    :disabled
    :straight t
    :config
    (dolist (binding '("C-<left>" "C-<right>" "C-M-<left>" "C-M-<right>" "M-s" "M-?"))
      (define-key paredit-mode-map (read-kbd-macro binding) nil))
    (paredit-mode)
    )
  (use-package elec-pair
    :disabled
    :hook
    (after-init-hook . electric-pair-mode)
    ;; org-mode 中存在bug，故关闭
    (org-mode-hook . (lambda ()(electric-pair-local-mode -1)))
    )
  (use-package smartparens
    :straight t
    :init
    (setq sp-highlight-wrap-overlay nil
          sp-highlight-pair-overlay nil
          sp-highlight-wrap-tag-overlay nil)
    :hook
    ((prog-mode-hook org-mode-hook conf-mode-hook) . smartparens-mode)
    ((lisp-mode-hook emacs-lisp-mode-hook lisp-interaction-mode-hook) . (lambda ()
                                    (evil-define-key* 'insert
                                      lisp-interaction-mode-map
                                      (kbd "DEL") #'sp-backward-delete-char
                                      (kbd "C-<backspace>") #'sp-backward-delete-word
                                      (kbd "C-w") #'sp-backward-delete-word)))
    :bind
    (:map evil-normal-state-map
          (")" . sp-up-sexp)
          ("(" . sp-backward-up-sexp))
    :config
    (require 'smartparens-config))
#+END_SRC

*** Show Paren Mode
开启括号配对显示
#+BEGIN_SRC emacs-lisp
  (use-package paren
    :hook
    (after-init-hook . show-paren-mode)
    :config
    (set-face-attribute 'show-paren-match nil
                        :underline '(:color "red" :position 0)
                        :background "unspecified"
                        :foreground "red"
                        :weight 'bold
                        ))
  ;; (add-hook 'after-init-hook 'show-paren-mode)
  ;; (add-hook 'show-paren-mode-hook (lambda ()
  ;;                                   (define-advice show-paren-function (:around (fn) fix-show-paren-function)
  ;;                                     "Highlight enclosing parens."
  ;;                                     (cond ((looking-at-p "\\s(") (funcall fn))
  ;;                                           (t (save-excursion
  ;;                                                (ignore-errors (backward-up-list))
  ;;                                                (funcall fn)))))
  ;;                                   (custom-set-faces
  ;;                                    `(show-paren-match ((t (:background ,
  ;;                                                            (face-attribute 'default :background)
  ;;                                                            :foreground "red")))))
  ;;                                   ))
#+END_SRC

** Snippet -- 模板补全
#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :straight t
    :hook
    (prog-mode-hook . yas-minor-mode)
    :bind
    (:map yas-keymap
          ("C-o" . yas-prev-field))
    :config
    (set-face-attribute 'yas-field-highlight-face nil
                        :background "unspecified"
                        :underline '(:color "white" :position 0)
                        :inherit nil)
    (yas--load-snippet-dirs))
#+END_SRC

** Multiple Cursors -- 多光标编辑
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :straight t
    :config
    (defhydra hydra-multiple-cursors(:foreign-keys warn
                                                   :hint nil)
      "
   增减光标^^        |  搜索标记^^               |  区域或所有              % 2(mc/num-cursors) cursor%s(if (> (mc/num-cursors) 1) \"s\" \"\")
  ------------------------------------------------------------------
   [_J_]   向下添加  |  [_V_]   矩形区域标记编辑  |  [_a_]   标记当前所有标记
   [_K_]   向上添加  |  [_;_]   向下搜索标记区域  |  [_r_]   选择区域搜索标记
   [_C-j_] 向下跳过  |  [_,_]   向上搜索标记区域  |  [_R_]   选择区域正则搜索
   [_C-k_] 向上跳过  |  [_s_]   标记当前符号向下  |  [_F_]   标记当前所有函数
   [_p_]   删除最下  |  [_S_]   标记当前符号向上  |  [_._]   智能标记添加光标
   [_n_]   删除最上  |  [_i_]   可按前缀插入数字  |  [_L_]   选择区域所有行尾
   [_j_]   基础移动  |  [_I_]   可按前缀插入字母  |  [_H_]   选择区域所有行首
  "
      ("j" evil-next-line)
      ("k" evil-previous-line)
      ("h" evil-backward-char)
      ("l" evil-forward-char)
      ("w" evil-forward-word-begin)
      ("e" evil-forward-word-end)
      ("b" evil-backward-word-begin)
      ("v" evil-visual-char)
      ("V" set-rectangular-region-anchor)
      ("J" mc/mark-next-lines)
      ("K" mc/mark-previous-lines)
      ("C-j" mc/skip-to-next-like-this)
      ("C-k" mc/skip-to-previous-like-this)
      ("p" mc/unmark-next-like-this)
      ("n" mc/unmark-previous-like-this)
      ("a" mc/mark-all-like-this)
      ("r" mc/mark-all-in-region)
      ("R" mc/mark-all-in-region-regexp)
      ("F" mc/mark-all-like-this-in-defun)
      ("." mc/mark-all-dwim)
      (";" mc/mark-next-like-this)
      ("," mc/mark-previous-like-this)
      ("s" mc/mark-next-like-this-symbol)
      ("S" mc/mark-previous-like-this-symbol)
      ("L" mc/edit-ends-of-lines)
      ("H" mc/edit-beginnings-of-lines)
      ("i" mc/insert-numbers)
      ("I" mc/insert-letters)
      ("C-g" mc/keyboard-quit "mc/keyboard-quit")
      ("q" nil "Quit"))
    (lmm/evil-space-leader-def
      "mc" 'hydra-multiple-cursors/body))

  ;; (setq mc/cmds-to-run-once
  ;;       '(
  ;;         hydra-multiple-cursors/body
  ;;         hydra-multiple-cursors/evil-next-line
  ;;         hydra-multiple-cursors/evil-previous-line
  ;;         hydra-multiple-cursors/evil-backward-char
  ;;         hydra-multiple-cursors/evil-forward-char
  ;;         hydra-multiple-cursors/evil-forward-word-begin
  ;;         hydra-multiple-cursors/evil-forward-word-end
  ;;         hydra-multiple-cursors/evil-backward-word-begin
  ;;         hydra-multiple-cursors/evil-visual-char
  ;;         hydra-multiple-cursors/set-rectangular-region-anchor
  ;;         hydra-multiple-cursors/mc/mark-next-lines
  ;;         hydra-multiple-cursors/mc/mark-previous-lines
  ;;         hydra-multiple-cursors/mc/skip-to-next-like-this
  ;;         hydra-multiple-cursors/mc/skip-to-previous-like-this
  ;;         hydra-multiple-cursors/mc/unmark-next-like-this
  ;;         hydra-multiple-cursors/mc/unmark-previous-like-this
  ;;         hydra-multiple-cursors/mc/mark-all-like-this
  ;;         hydra-multiple-cursors/mc/mark-all-in-region
  ;;         hydra-multiple-cursors/mc/mark-all-in-region-regexp
  ;;         hydra-multiple-cursors/mc/mark-all-like-this-in-defun
  ;;         hydra-multiple-cursors/mc/mark-all-dwim
  ;;         hydra-multiple-cursors/mc/mark-next-like-this
  ;;         hydra-multiple-cursors/mc/mark-previous-like-this
  ;;         hydra-multiple-cursors/mc/mark-next-like-this-symbol
  ;;         hydra-multiple-cursors/mc/mark-previous-like-this-symbol
  ;;         hydra-multiple-cursors/mc/edit-ends-of-lines
  ;;         hydra-multiple-cursors/mc/edit-beginnings-of-lines
  ;;         hydra-multiple-cursors/mc/insert-numbers
  ;;         hydra-multiple-cursors/mc/insert-letters
  ;;         hydra-multiple-cursors/mc/keyboard-quit
  ;;         hydra-multiple-cursors/nil))
#+END_SRC

** Better Jump
#+BEGIN_SRC emacs-lisp
  (use-package better-jumper
    :straight t
    :hook
    (after-init-hook . better-jumper-mode)
    :config
    (evil-define-key '(normal motion visual) 'global
      "\C-o" #'better-jumper-jump-backward
      "\C-i" #'better-jumper-jump-forward))
#+END_SRC

** Hide Show Code Block Mode 代码折叠
doc -> [[https://www.emacswiki.org/emacs/HideShow][HideShow]]
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'hs-minor-mode)
  (defun +hs-display-code-line-counts (ov)
    "代码折叠提示, help-echo 可通过 show-help-function 配置.
  默认为minibuffer 提示, 可以打开tooltip-mode 进行更好的提示."
    (when (eq 'code (overlay-get ov 'hs))
      (overlay-put ov 'help-echo
                   (buffer-substring (overlay-start ov)
                                     (overlay-end ov)))
      (overlay-put ov 'display
                   (propertize (format "   -- %d lines --  "
                                       (count-lines (overlay-start ov)(overlay-end ov)))
                               'face '(:inherit 'custom-comment-tag)))))

  (setq hs-set-up-overlay #'+hs-display-code-line-counts)

  (defun +toggle-selective-display (column)
    "按照缩进折叠, 作用于全局, 局部块可以用 hs-hide-level"
    (interactive "P")
    (set-selective-display
     (or column
         (unless selective-display
           (1+ (current-column))))))

  (defun +toggle-hiding (column)
    (interactive "P")
    (if hs-minor-mode
        (if (condition-case nil
                (hs-toggle-hiding)
              (error t))
            (hs-show-all))
      (+toggle-selective-display column)))
#+END_SRC

** Text Conver
#+BEGIN_SRC emacs-lisp
  (defun lmm/conver-thing-word(region)
    "Conver thing at point word."
    (interactive (list (bounds-of-thing-at-point 'word)))
    (when region
      (let* ((case-fold-search nil)
            (beg (car region))
            (end (cdr region))
            (substring (buffer-substring-no-properties beg end))
            (capitalize-rx "^[[:upper:]][^[:upper:]]*$")
            (uppercase-rx "^[[:upper:]]*$")
            (lowercase-rx "^[[:lower:]]*$"))
        (cond
         ((string-match lowercase-rx substring nil t)
          (capitalize-region beg end))
         ((string-match capitalize-rx substring nil t)
          (upcase-region beg end))
         (t
          (downcase-region beg end))))))

  (evil-define-key* 'insert 'global
    (kbd "C-t") #'lmm/conver-thing-word)
#+END_SRC

** Save File Place
保存打开过的文件的光标位置
#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :hook
    (after-init-hook . save-place-mode))
#+END_SRC

** Recent File
保存打开过的文件
#+BEGIN_SRC emacs-lisp
  (use-package recentf
    :hook
    (after-init-hook . recentf-mode)
    :init
    (setq recentf-max-saved-items 100
          recentf-auto-cleanup 'never)
    :config
    (recentf-load-list))
#+END_SRC

* LANG CONFIG
** Complete Config
*** Corfu -- other completion tool
**** Install
#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :straight (:files (:defaults "extensions/*"))
    :init
    ;; 自动触发补全
    (setq corfu-auto t
          ;; 补全预览
          corfu-preview-current nil

          ;; 补全候选预选
          ;; corfu-preselect-first nil
          ;; 禁用minibuffer文档显示
          corfu-echo-documentation nil
          ;; 滚动边距
          ;; corfu-scroll-margin 2
          corfu-min-width 80
          corfu-max-width corfu-min-width
          corfu-count 15
          corfu-auto-delay 0.3
          )
    :hook
    (after-init-hook . global-corfu-mode)
    (corfu-mode-hook . corfu-history-mode)
    :bind
    (:map corfu-map
          ("C-n" . corfu-next)
          ("C-p" . corfu-previous)
          ("M-<" . corfu-first)
          ("M->" . corfu-last)
          ("C-v" . corfu-scroll-up)
          ("M-v" . corfu-scroll-down)
          ("C-'" . corfu-quick-jump)
          ("C-." . corfu-quick-insert)
          ("C-," . corfu-quick-complete)
          ("C-i" . corfu-complete)
          ("<tab>" . corfu-insert-separator)
          ("C-SPC" . corfu-insert-separator)
          ("C-g" . corfu-quit))
    :config
    ;; insert模式下按键失效，需此设置
    (advice-add 'corfu--setup :after (lambda (&rest _) (evil-normalize-keymaps)))
    (advice-add 'corfu--teardown :after (lambda (&rest _) (evil-normalize-keymaps)))
    (evil-make-overriding-map corfu-map)
    (setq lsp-completion-provider :none)
    (defun lmm/lsp-mode-setup-completion()
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
            '(orderless)))
    (add-hook 'lsp-completion-mode-hook 'lmm/lsp-mode-setup-completion)

    (defun corfu-move-to-minibuffer ()
      (interactive)
      (let ((completion-extra-properties corfu--extra)
            completion-cycle-threshold completion-cycling)
        (apply #'consult-completion-in-region completion-in-region--data)))

    (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer)


    (set-face-background 'corfu-current "#44475a")
    (set-face-background 'corfu-border "#ffc4cd")
    (set-face-background 'corfu-default "#282a36")
    )

  ;; built in corfu
  (use-package corfu-popupinfo
    :init
    (setq corfu-popupinfo-delay nil)
    :hook
    (corfu-mode-hook . corfu-popupinfo-mode)
    :bind
    (:map corfu-map
          ("M-h" . corfu-popupinfo-documentation)
          ("M-t" . corfu-popupinfo-toggle)
          ("M-." . corfu-popupinfo-location)
          ("M-n" . corfu-popupinfo-scroll-up)
          ("M-p" . corfu-popupinfo-scroll-down)))
#+END_SRC

**** cape -- complete backends
#+BEGIN_SRC emacs-lisp
  ;; cape-dabbrev:当前缓冲区的完整单词
  ;; cape-file:完整的文件名
  ;; cape-keyword:完整的编程语言关键字
  ;; cape-symbol:完整的 elisp 符号
  ;; cape-abbrev:完整缩写(add-global-abbrev, add-mode-abbrev)
  ;; cape-ispell:Ispell 词典中的完整单词
  ;; cape-dict:字典文件中的完整单词
  ;; cape-line:从当前缓冲区完成整行
  ;; cape-tex:来自 Tex 命令的完整 unicode 字符
  ;; cape-sgml:来自 sgml 完整的 unicode 字符
  ;; cape-rfc1345: unicode
  (use-package cape
    :straight t
    :config
    (dolist (hook '(lisp-mode-hook
                    emacs-lisp-mode-hook
                    lisp-interaction-mode-hook))
      (add-hook hook
                (lambda()
                  (setq-local completion-at-point-functions
                              '(cape-elisp-symbol cape-dabbrev cape-file)))))

    (dolist (hook '(rustic-mode-hook))
      (add-hook hook
                (lambda()
                  (setq-local completion-at-point-functions
                              (append completion-at-point-functions '(cape-dabbrev cape-file)))))))
#+END_SRC

**** nerd-icons-corfu
#+BEGIN_SRC emacs-lisp
  (use-package corfu
    :defer t
    :config
    (defvar +nerd-icons-corfu-cache nil
      "The cache of styled and padded label (text or icon).
  An alist.")

    (defun +nerd-icons-corfu-reset-cache ()
      "Remove all cached icons from `+nerd-icons-corfu-mapping'."
      (interactive)
      (setq +nerd-icons-corfu-cache nil))

    (defvar +nerd-icons-corfu-mapping
      (let ((space-left (propertize " " 'display '(space :width 0.5)))
            (space-right (propertize " " 'display '(space :width 1)))
            (icons `((array ,(nerd-icons-codicon "nf-cod-symbol_array" :face 'font-lock-type-face))
                     (boolean ,(nerd-icons-codicon "nf-cod-symbol_boolean" :face 'font-lock-builtin-face))
                     (class ,(nerd-icons-codicon "nf-cod-symbol_class" :face 'font-lock-type-face))
                     (color ,(nerd-icons-codicon "nf-cod-symbol_color" :face 'success))
                     (command ,(nerd-icons-codicon "nf-cod-terminal" :face 'default))
                     (constant ,(nerd-icons-codicon "nf-cod-symbol_constant" :face 'font-lock-constant-face))
                     (constructor ,(nerd-icons-codicon "nf-cod-triangle_right" :face 'font-lock-function-name-face))
                     (enummember ,(nerd-icons-codicon "nf-cod-symbol_enum_member" :face 'font-lock-builtin-face))
                     (enum-member ,(nerd-icons-codicon "nf-cod-symbol_enum_member" :face 'font-lock-builtin-face))
                     (enum ,(nerd-icons-codicon "nf-cod-symbol_enum" :face 'font-lock-builtin-face))
                     (event ,(nerd-icons-codicon "nf-cod-symbol_event" :face 'font-lock-warning-face))
                     (field ,(nerd-icons-codicon "nf-cod-symbol_field" :face 'font-lock-variable-name-face))
                     (file ,(nerd-icons-codicon "nf-cod-symbol_file" :face 'font-lock-string-face))
                     (folder ,(nerd-icons-codicon "nf-cod-folder" :face 'font-lock-doc-face))
                     (interface ,(nerd-icons-codicon "nf-cod-symbol_interface" :face 'font-lock-type-face))
                     (keyword ,(nerd-icons-codicon "nf-cod-symbol_keyword" :face 'font-lock-keyword-face))
                     (macro ,(nerd-icons-codicon "nf-cod-symbol_misc" :face 'font-lock-keyword-face))
                     (magic ,(nerd-icons-codicon "nf-cod-wand" :face 'font-lock-builtin-face))
                     (method ,(nerd-icons-codicon "nf-cod-symbol_method" :face 'font-lock-function-name-face))
                     (function ,(nerd-icons-codicon "nf-cod-symbol_method" :face 'font-lock-function-name-face))
                     (module ,(nerd-icons-codicon "nf-cod-file_submodule" :face 'font-lock-preprocessor-face))
                     (mod ,(nerd-icons-codicon "nf-cod-file_submodule" :face 'font-lock-preprocessor-face))
                     (numeric ,(nerd-icons-codicon "nf-cod-symbol_numeric" :face 'font-lock-builtin-face))
                     (operator ,(nerd-icons-codicon "nf-cod-symbol_operator" :face 'font-lock-comment-delimiter-face))
                     (param ,(nerd-icons-codicon "nf-cod-symbol_parameter" :face 'default))
                     (property ,(nerd-icons-codicon "nf-cod-symbol_property" :face 'font-lock-variable-name-face))
                     (reference ,(nerd-icons-codicon "nf-cod-references" :face 'font-lock-variable-name-face))
                     (snippet ,(nerd-icons-codicon "nf-cod-symbol_snippet" :face 'font-lock-string-face))
                     (string ,(nerd-icons-codicon "nf-cod-symbol_string" :face 'font-lock-string-face))
                     (struct ,(nerd-icons-codicon "nf-cod-symbol_structure" :face 'font-lock-variable-name-face))
                     (text ,(nerd-icons-codicon "nf-cod-text_size" :face 'font-lock-doc-face))
                     (typeparameter ,(nerd-icons-codicon "nf-cod-list_unordered" :face 'font-lock-type-face))
                     (type-parameter ,(nerd-icons-codicon "nf-cod-list_unordered" :face 'font-lock-type-face))
                     (unit ,(nerd-icons-codicon "nf-cod-symbol_ruler" :face 'font-lock-constant-face))
                     (value ,(nerd-icons-codicon "nf-cod-symbol_field" :face 'font-lock-builtin-face))
                     (variable ,(nerd-icons-codicon "nf-cod-symbol_variable" :face 'font-lock-variable-name-face))
                     (t ,(nerd-icons-codicon "nf-cod-code" :face 'font-lock-warning-face)))))
        (dolist (icon icons)
          (setf (cadr icon) (concat space-left (cadr icon) space-right)))
        icons)
      "Mapping of completion kinds to icons.

  It should be a list of elements with the form (KIND ICON-TXT [:face FACE]).
  KIND is a symbol determining what the completion is, and comes from calling the
  `:company-kind' property of the completion. ICON-TXT is a string with the icon
  to use, usually as a character from a `nerd-icons' symbol font. See that
  package for how to get these. Note that it can be simple text if that is
  preferred. FACE, if present, is applied to the icon, mainly for its color. The
  special t symbol should be used for KIND to represent the default icon, and
  must be present.")

    (defun +nerd-icons-corfu-formatter (metadata)
      "A margin formatter for corfu, adding icons.

  It receives METADATA and outputs a function that takes a candidate and returns
  the icon."
      (when-let ((kindfunc (or (plist-get completion-extra-properties :company-kind)
                               (assq 'company-kind metadata))))
        (lambda (cand)
          (let ((kind (or (funcall kindfunc cand) t)))
            (or (alist-get kind +nerd-icons-corfu-cache)
                (let* ((icon-entry (assq kind +nerd-icons-corfu-mapping))
                       (str (cadr icon-entry))
                       ;; (props (cddr icon-entry))
                       ;; (extra-face (plist-get props :face))
                       ;; (space (propertize " " 'display '(space :width 1)))
                       ;; (str (concat str " "))
                       )
                  ;; (when extra-face
                  ;;   (put-text-property 0 3 'face extra-face str))
                  (setf (alist-get kind +nerd-icons-corfu-cache) str)
                  str)))
          )))

    (setq corfu-margin-formatters '(+nerd-icons-corfu-formatter))
    )
#+END_SRC

** Syntax Checking
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :straight t
    :init
    (setq flycheck-buffer-switch-check-intermediate-buffers t)
    :hook
    (prog-mode-hook . flycheck-mode)
    :config
    (delq 'new-line flycheck-check-syntax-automatically))
#+END_SRC

** Lsp Server Config
[[https://emacs-lsp.github.io/lsp-mode/tutorials/how-to-turn-off/][lsp display config]]
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :straight t
    :init
    (setq lsp-auto-guess-root t
          lsp-prefer-flymake nil
          lsp-auto-configure t
          ;; 符号高亮
          lsp-enable-symbol-highlighting t
          lsp-symbol-highlighting-skip-current t
          ;; 关闭底部eldoc 提示
          lsp-eldoc-enable-hover nil
          ;; 关闭状态栏代码操作提示
          lsp-modeline-code-actions-enable nil
          ;; 关闭状态栏诊断提示
          lsp-modeline-diagnostics-enable nil
          ;; 关闭模板生成
          lsp-enable-snippet t
          ;; 关闭折叠
          lsp-enable-folding nil
          ;; 关闭 minibuffer 签名和文档显示
          lsp-signature-auto-activate nil
          ;; 关闭 lens
          lsp-lens-enable nil
          ;; 关闭 headerline
          lsp-headerline-breadcrumb-enable nil
          )
    :hook
    ;; lsp-deferred 等待buffer完全可见后启用 lsp
    ((c-mode-hook) . lsp-deferred)
    (lsp-mode-hook . lsp-enable-which-key-integration)
    :config
    ;; (delq 'company-capf company-backends)
    ;; (add-to-list 'company-backends 'company-capf)
    (lmm/evil-space-leader-def
      "ls" 'lsp-signature-activate)
    (set-face-attribute 'lsp-face-highlight-textual nil
                        :background "unspecified"
                        :underline '(:color "#fce38a" :position 0)
                        :foreground "unspecified"
                        )
    ;; (set-face-attribute 'lsp-face-highlight-write nil :background "unspecified")
    ;; (set-face-attribute 'lsp-face-highlight-read nil :background "unspecified")
    :commands lsp)

  (use-package lsp-ui
    :straight t
    :init
    ;; 错误检查提示延迟
    (setq lsp-ui-sideline-delay 0.4
          ;; 操作提示
          lsp-ui-sideline-show-code-actions nil)
    :commands lsp-ui-mode
    :config
    (setq lsp-ui-sideline-actions-icon lsp-ui-sideline-actions-icon-default)
    (lmm/evil-space-leader-def
      "lds" 'lsp-ui-doc-show
      "ldh" 'lsp-ui-doc-hide
      ))
#+END_SRC

** Another Lsp Server
#+BEGIN_SRC emacs-lisp
  (use-package eglot
    :disabled
    :no-require t
    :straight t
    :commands eglot eglot-ensure)

  ;; very fast lsp server
  ;; need python module
  ;; pip install epc orjson
  ;; need emacs plugin
  ;; posframe markdown-mode yasnippet
  ;; https://github.com/manateelazycat/lsp-bridge
  (use-package lsp-bridge
    :straight (:host github
                     :repo "manateelazycat/lsp-bridge"
                     :branch "master"
                     :files (:defaults "acm/*")
                     :build nil)
    :load-path "straight/repos/lsp-bridge"
    :init
    (setq lsp-bridge-enable-log nil
          lsp-bridge-enable-debug nil)
    :commands (lsp-bridge-mode global-lsp-bridge-mode)
    ;; :hook
    ;; (prog-mode-hook . lsp-bridge-mode)
    ;; (lsp-bridge-mode-hook . acm-mode)
    :config
    (add-hook 'lsp-bridge-mode-hook (lambda ()
                                      (when (and (featurep 'corfu) corfu-mode)
                                        (corfu-mode -1))))
    (advice-add 'acm-update :after #'evil-normalize-keymaps)
    (evil-make-overriding-map acm-mode-map)
    (define-key acm-mode-map (kbd "C-n") #'acm-select-next)
    (define-key acm-mode-map (kbd "C-p") #'acm-select-prev)
    )
#+END_SRC

** Tree Sitter
#+BEGIN_SRC emacs-lisp
  (use-package treesit
    :defer t
    :init
    (setq treesit-font-lock-level 4))
#+END_SRC

** Format Code
#+BEGIN_SRC emacs-lisp
  (use-package apheleia
    :straight t
    :commands apheleia-format-buffer
    )
#+END_SRC

** LANG
*** rust
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :straight t
    :commands rust-mode
    )
  (use-package rustic
    :straight t
    :mode
    ("\\.rs$" . rustic-mode)
    :init
    ;; (setq rustic-lsp-server 'rls)
    (setq rustic-lsp-client 'lsp)
    ;; (setq rustic-lsp-client 'eglot)
    :commands rustic-mode
    :config
    (add-hook 'rust-mode-hook (lambda () (setq-local company-backends '(company-capf
                                                                          (company-yasnippet company-dabbrev-code company-keywords)
                                                                          company-dabbrev
                                                                          company-files
                                                                          ))))
    (general-define-key
     :keymaps 'rustic-mode-map
     "<f5>" '(lambda ()(interactive) (save-buffer)(rustic-cargo-run)))

    (setq rustic-indent-method-chain t)
    (setq rustic-babel-format-src-block nil
          rustic-format-trigger nil)
    ;; hook 引入太早容易出现问题
    ;; (remove-hook 'rustic-mode-hook #'flycheck-mode)
    ;; (remove-hook 'rustic-mode-hook #'flymake-mode-off)
    ;; (unless (featurep 'lsp)
    ;;   (add-to-list 'flycheck-checker 'rustic-clippy))
    ;; (when (featurep 'lsp)
    ;;   (setq lsp-rust-analyzer-cargo-watch-command 'clippy)
    ;;   (remove-hook 'rustic-mode-hook #'rustic-setup-lsp)
    ;;   (add-hook 'rustic-mode-local-vars-hook #'rustic-setup-lsp))
    )
#+END_SRC

*** emacs-lisp
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook (lambda ()
                                    (setq-local company-backends '(company-elisp
                                                                   company-files
                                                                   (company-dabbrev-code company-keywords company-dabbrev)
                                                                   company-capf))))
#+END_SRC

*** lua
#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :straight t
    :init
    (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
    (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
    (setq lua-indent-level 2)
    (setq lua-indent-string-contents t)
    (setq lua-indent-close-paren-align nil)
    :commands lua-mode)
#+END_SRC

*** markdown-mode
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :straight t
    :commands markdown-mode
    :mode
    ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command "multimarkdown"))
#+END_SRC

*** json-mode
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode ("\\.jsonc\\'" . jsonc-mode)
    :straight t
    :defer t
    :init
    (setq lsp-json-schemas `[(:fileMatch ["*.schema.json"]
                                         :url "https://json-schema.org/draft/2020-12/schema")])
    :config
    (add-hook 'json-mode-hook (lambda ()(setq-local js-indent-level 2)))
    (when (featurep 'flycheck)
      (add-to-list 'flycheck-checkers 'json5 t)
      (flycheck-define-checker json5
        "A JSON syntax checker using json5.

  support json comment. please run cmd: npm install -g json5."
        :command ("json5" "-v" source)
        :error-patterns
        ((error line-start
                (message)
                "at " line
                ":" column line-end))
        :modes (jsonc-mode json-ts-mode))))
#+END_SRC

*** web
#+BEGIN_SRC emacs-lisp
  (use-package verb
    :straight t
    :init
    (setq verb-babel-timeout 3.0)
    :commands verb-mode)
#+END_SRC

*** sh
#+BEGIN_SRC emacs-lisp
  (setq sh-basic-offset 2)
#+END_SRC

*** yaml
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :straight t
     )
#+END_SRC

*** go
#+BEGIN_SRC emacs-lisp
  (use-package go-mode
    :straight t
    :commands go-mode)
#+END_SRC

* WORKSPACE
** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :straight t
    :hook
    (after-init-hook . projectile-mode)
    :init
    (setq-default projectile-mode-line-prefix " Proj")
    :config
    (when (executable-find "rg")
      (setq-default projectile-generic-command "rg --files --hidden"))

    (lmm/evil-space-leader-def
      "p" projectile-command-map)
    (general-define-key
     :keymaps 'projectile-command-map
     "A" #'projectile-add-known-project))

  (use-package ibuffer-projectile
    :straight t
    :after projectile)
#+END_SRC

** Perspective
#+BEGIN_SRC emacs-lisp
  (use-package perspective
    :straight t
    :init
    ;; 按最近使用排序buffer
    (setq persp-sort 'access
          ;; 是否在modeline中显示
          persp-show-modestring t
          persp-suppress-no-prefix-key-warning t
          persp-modestring-dividers `(,(propertize "[" 'face '(:foreground "yellow"))
                                      ,(propertize "]" 'face '(:foreground "yellow"))
                                      ,(propertize "|" 'face '(:foreground "yellow"))))
    :after consult
    :config
    (progn
      (persp-mode t)
      ;; consult buffers by persp
      (consult-customize consult--source-buffer :hidden t :default nil :narrow ?B)
      (delq 'consult--source-buffer consult-buffer-sources)

      (defvar lmm/perspective-consult--source-buffer
        (list :name     (format "Current Persp Buffers")
              :narrow   ?b
              :category 'buffer
              :history 'buffer-name-history
              :state    #'consult--buffer-state
              :default  t
              :items
              #'(lambda () (consult--buffer-query :sort 'visibility
                                                  :predicate '(lambda (buf) (persp-is-current-buffer buf t))
                                                  :as #'buffer-name))))

      (add-to-list 'consult-buffer-sources 'lmm/perspective-consult--source-buffer)

      (defvar lmm/consult--source-org-buffer
        (list :name     "Org Buffer"
              :category 'buffer
              :hidden t
              :narrow   ?o
              :face     'consult-buffer
              :history  'buffer-name-history
              :state    #'consult--buffer-state
              :new
              (lambda (name)
                (with-current-buffer (get-buffer-create name)
                  (insert "#+TITLE: " name "\n\n")
                  (org-mode)
                  (consult--buffer-action (current-buffer))))
              :items
              (lambda ()
                (mapcar #'buffer-name
                        (seq-filter
                         (lambda (x)
                           (eq (buffer-local-value 'major-mode x) 'org-mode))
                         (persp-get-buffers))))))
      (add-to-list 'consult-buffer-sources 'lmm/consult--source-org-buffer 'append)

      (defvar lmm/consult--source-vterm-buffer
        (list :name     "vterm Buffer"
              :category 'buffer
              :hidden t
              :narrow   ?v
              :face     'consult-buffer
              :history  'buffer-name-history
              :state    #'consult--buffer-state
              :items
              (lambda ()
                (mapcar #'buffer-name
                        (seq-filter
                         (lambda (x)
                           (eq (buffer-local-value 'major-mode x) 'vterm-mode))
                         (persp-get-buffers))))))
      ;; (add-to-list 'consult-buffer-sources 'lmm/consult--source-vterm-buffer 'append)

      (defvar lmm/consult--source-dired-buffer
        (list :name     "Dired Buffer"
              :category 'buffer
              :hidden t
              :narrow   ?d
              :face     'consult-buffer
              :history  'buffer-name-history
              :state    #'consult--buffer-state
              :items
              (lambda ()
                (mapcar #'buffer-name
                        (seq-filter
                         (lambda (x)
                           (eq (buffer-local-value 'major-mode x) 'dired-mode))
                         (persp-get-buffers))))))
      ;; (add-to-list 'consult-buffer-sources 'lmm/consult--source-dired-buffer 'append)

      (defun lmm/persp-consult-all-buffer()
        "Perspective all buffer by consult"
        (interactive)
        (persp-switch-to-buffer
         (car (consult--multi
               (mapcar (lambda (p) `(:name ,p
                                           :category buffer
                                           :face consult-buffer
                                           :default ,(string= "main" p)
                                           :items
                                           ,(persp-get-buffer-names p)))
                       (persp-names))
               :prompt "Persp All Buffer: "
               :history nil
               :sort nil
               ))))

      (define-keymap
        :keymap perspective-map
        "<tab>" 'persp-switch
        "j" #'persp-next
        "k" #'persp-prev
        "d" (defun +persp-kill-current ()
              "Kill current perspective"
              (interactive)
              (persp-kill (persp-current-name))))
      (lmm/evil-space-leader-def
        "," #'consult-buffer
        "<" #'lmm/persp-consult-all-buffer
        "<tab>" perspective-map)
      ))
#+END_SRC

** Treemacs -- 文件树
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :straight t
    :defer t
    :bind
    (:map lmm/evil-space-leader-def-map
          (";" . treemacs-select-window)))
  (use-package treemacs-evil
    :straight t
    :after (treemacs evil)
    :config
    (define-key evil-treemacs-state-map (kbd "q") 'treemacs-quit))

  (use-package treemacs-icons-dired
    :straight t
    :hook
    (dired-mode-hook . treemacs-icons-dired-enable-once))
#+END_SRC

** Git
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :straight t
    :init
    (setq-default magit-diff-refine-hunk t)
    :commands magit-status magit-dispatch
    :bind
    (:map lmm/evil-space-leader-def-map
          ("gi" . magit-dispatch)
          ("g." . magit))
    )
#+END_SRC

** Dired
避免在 dired 中前进和后退新建 buffer
#+BEGIN_SRC emacs-lisp
  (put 'dired-find-alternate-file 'disabled nil)
  (use-package dired
    :init
    (setq dired-listing-switches "-alh")
    :commands (dired dired-jump)
    :config
    (defun +dired-up-alternate()
      "Dired up directory -- alternate"
      (interactive)
      (if (equal major-mode 'dired-mode)
          (find-alternate-file "..")
        (message "You not in dired-mode")))

    (defun +dired-find-alternate-file-if-directory()
      "dired-mode:
    dired-find-alternate-file if you select is a directory"
      (interactive)
      (if (equal major-mode 'dired-mode)
          (if (file-directory-p (dired-get-filename))
              (dired-find-alternate-file)
            (when (yes-or-no-p "This is a file, you sure open this file?")
              (dired-find-file)))
        (message "You not in dired-mode")))

    (defvar +dired-recent-dir-list nil)
    (defun +dired-push-dir()
      (when dired-directory
        (add-to-list '+dired-recent-dir-list dired-directory)))

    (defun +dired-goto-recent-dir(path)
      "Dired goto recent directory."
      (interactive (list (completing-read "Goto recent path: "
                                          +dired-recent-dir-list)))
      (when (and path (file-exists-p path))
        (find-alternate-file path)))
    (add-hook 'dired-after-readin-hook '+dired-push-dir)
    (evil-define-key* 'normal dired-mode-map "gj" #'+dired-goto-recent-dir)

    (general-define-key
     :states '(normal motion)
     :keymaps 'dired-mode-map
     "h" '+dired-up-alternate
     "l" '+dired-find-alternate-file-if-directory)

    (lmm/evil-space-leader-def
      "df" 'dired
      "d." 'dired-at-point
      "dj" 'dired-jump)

    (put 'dired-jump 'repeat-map nil)
    )

  (use-package dired-hacks
    :straight t
    :after dired
    :bind
    (:map dired-mode-map
          ("C-c m" . dired-ranger-move)
          ("C-c p" . dired-ranger-paste)
          ("C-c c" . dired-ranger-copy)
          ("C-c o" . dired-open)
          ("C-c ;" . dired-collapse-mode)
          ("C-c l f" . dired-list-find-file)
          ("C-c l n" . dired-list-find-name)
          ("C-c l g" . dired-list-git-ls-files)
          ("C-c TAB" . dired-subtree-toggle)
          ([remap evil-toggle-fold] . dired-subtree-toggle)))
#+END_SRC

** Diff
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :straight t
    :hook
    (after-init-hook . global-diff-hl-mode)
    (dired-mode-hook . diff-hl-dired-mode-unless-remote)
    (magit-pre-refresh-hook . diff-hl-magit-pre-refresh)
    (magit-post-refresh-hook . diff-hl-magit-post-refresh)
    :config
    (evil-define-key '(normal motion) diff-hl-show-hunk-map
      "n" #'diff-hl-show-hunk-next
      "p" #'diff-hl-show-hunk-previous
      "r" #'diff-hl-revert-hunk
      "c" #'diff-hl-show-hunk-copy-original-text
      "q" 'diff-hl-inline-popup-hide
      (kbd "<escape>") 'diff-hl-inline-popup-hide
      "j" 'diff-hl-inline-popup--popup-down
      "k" 'diff-hl-inline-popup--popup-up
      (kbd "C-f") 'diff-hl-inline-popup--popup-pagedown
      (kbd "C-b") 'diff-hl-inline-popup--popup-pageup)
    (lmm/evil-space-leader-def
      "gd" #'diff-hl-show-hunk))
#+END_SRC

* SYSTEM
** Vterm
#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :if (memq system-type '(gnu gnu/linux))
    :straight t
    :bind
    ("<f12>" . vterm)
    :init
    (setq vterm-timer-delay 0.05)
    ;; (add-to-list 'evil-insert-state-modes 'vterm-mode)
    :config
    (add-to-list 'display-buffer-alist
                 '("\\*vterm\\*\\(<[0-9]>\\)?$"
                   display-buffer-at-bottom))
    (general-define-key
     :keymaps 'vterm-mode-map
     "<f12>" (lambda (&optional count)(interactive "p")
               (cond ((> count 1) (delete-window)(vterm count))
                     ((one-window-p)
                      (switch-to-buffer (other-buffer)))
                     (t (delete-window))))
     "C-h" #'vterm-send-C-h
     "C-y" #'vterm-send-C-y
     "M-y" #'vterm-send-M-y
     "C-q" #'vterm-send-next-key
     )

    (general-define-key
     :states 'insert
     :keymaps 'vterm-mode-map
     "j" #'evil-vterm-escape)

    (defun evil-vterm-escape()
      "Vterm escape key \"jk\"."
      (interactive)
      (when (eq evil-state 'insert)
        (vterm-send-key "j")
        (let ((evt (read-event nil nil 0.1)))
          (cond ((and (characterp evt)
                      (equal ?k evt))
                 (evil-repeat-stop)
                 (vterm-send-key "")
                 (call-interactively #'evil-normal-state)
                 )
                ((null evt))
                (t
                 (setq unread-command-events
                       (append unread-command-events (list evt))))
                ))))

    (defun +evil-vterm-delete-char()
      (interactive)
      (vterm-goto-char (point))
      (call-interactively #'vterm-send-C-d))

    (defun +evil-vterm-append()
      (interactive)
      (vterm-goto-char (point))
      (call-interactively #'evil-append)
      (call-interactively #'vterm-send-right))

    (general-define-key
     :states 'normal
     :keymaps 'vterm-mode-map
     "x" #'+evil-vterm-delete-char
     "a" #'+evil-vterm-append)

    (add-hook 'vterm-exit-functions
              (lambda (buffer &optional arg)
                "Vterm exit command will call interactive func 'delete-window'"
                (when (not (one-window-p))
                  (call-interactively 'delete-window))))

    (defun +tramp-vterm-set-prompt()
      "If use tramp, auto recover shell prompt."
      (when (tramp-tramp-file-p buffer-file-name)
        (vterm-send-string "TERM=xterm-256color exec $SHELL")
        (vterm-send-return)))
    (add-hook 'vterm-mode-hook '+tramp-vterm-set-prompt)

    (add-hook 'vterm-mode-hook (lambda ()(setq-local evil-normal-state-cursor '(box "gold")
                                                     evil-insert-state-cursor '(box "cyan"))))
    ;; (evil-make-intercept-map vterm-mode-map 'insert)
    :commands vterm)
#+END_SRC

配合 vterm 的 shell 配置
#+BEGIN_SRC sh :tangle no
  if [[ "$INSIDE_EMACS" = 'vterm' ]]; then
    function vterm_printf(){
      if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
        # Tell tmux to pass the escape sequences through
        printf "\ePtmux;\e\e]%s\007\e\\" "$1"
      elif [ "${TERM%%-*}" = "screen" ]; then
        # GNU screen (screen, screen-256color, screen-256color-bce)
        printf "\eP\e]%s\007\e\\" "$1"
      else
        printf "\e]%s\e\\" "$1"
      fi
    }
    function vterm_prompt_end() {
      vterm_printf "51;A$(whoami)@$(cat /etc/hostname):$(pwd)";
    }

    # setopt PROMPT_SUBST
    # PROMPT=$PROMPT'%{$(vterm_prompt_end)%}'

    function vterm_cmd() {
      local vterm_elisp
      vterm_elisp=""
      while [ $# -gt 0 ]; do
        vterm_elisp="$vterm_elisp""$(printf '"%s" ' "$(printf "%s" "$1" | sed -e 's|\\|\\\\|g' -e 's|"|\\"|g')")"
        shift
      done
      vterm_printf "51;E$vterm_elisp"
    }

    function find_file() {
      vterm_cmd find-file "$(realpath "${@:-.}")"
    }

    alias e="find_file"
  fi
#+END_SRC

** Open Emacs In Term
#+BEGIN_SRC emacs-lisp
  ;; 导出环境变量 －－ EDITOR
  (use-package with-editor
    :straight t
    :hook
    (shell-mode-hook . with-editor-export-editor)
    (eshell-mode-hook . with-editor-export-editor)
    (term-exec-hook . with-editor-export-editor)
    (vterm-mode-hook . with-editor-export-editor)
    :config
    ;; (shell-command-with-editor-mode)
    ;; (define-key (current-global-map)
    ;;             [remap async-shell-command] 'with-editor-async-shell-command)
    ;; (define-key (current-global-map)
    ;;             [remap shell-command] 'with-editor-shell-command)
    )
#+END_SRC

** Remote Dev -> Tramp
#+BEGIN_SRC emacs-lisp
  (use-package tramp
    :defer t
    :init
    (setq tramp-terminal-type "dumb")
    :config
    ;; 远程提示符复杂时会无法连接,需要提供简单清晰的提示符,可覆盖远程 shell,
    ;; 覆盖远程 shell,只作用于 sshx 和 plink。
    (add-to-list 'tramp-connection-properties
                 (list (regexp-quote "/ssh:.*")
                       "remote-shell" "/usr/bin/bash"))
    ;; 其他远程shell需要在配置开头加上
    ;; [[ $TERM == "dumb" ]] && PS1='$ ' && return
    ;; 或者 zsh:
    ;; [[ $TERM == "dumb" ]] && unsetopt zle && PS1='$ ' && return
    ;; TERM 值应与 tramp-terminal-type 相同
    )
#+END_SRC

* OTHER UTILS
** Word Translate
#+BEGIN_SRC emacs-lisp
  (defun lmm/translate-word-at-point (p)
    (interactive "P")
    (let ((word (word-at-point p))
          valuestr)
      (if word
          (setq valuestr (shell-command-to-string (concat "sdcv -e -u 朗道英汉字典5.0 " (downcase word))))
        (setq valuestr "word not found at point"))
      (if (featurep 'popup)
          (popup-tip valuestr)
        (message valuestr)))
    )

  ;; C-x 8 RET is insert-char, have unicode
  ;; (defun lmm/consult-display-unicode ()
  ;;   "display unicode by consult"
  ;;   (interactive)
  ;;   (let ((names (ucs-names))
  ;;         (char-alias ()))
  ;;     (maphash (lambda (name char)
  ;;                (push (cons (format "0x%06X\t%s\t%s" char (char-to-string char) name) char) char-alias))
  ;;              names)
  ;;     (completing-read "Unicode Display: " (sort char-alias (lambda (a b)
  ;;                                                             (< (cdr a) (cdr b)))))))

  ;;;###autoload
  (defun lmm/rename-buffer-and-file-name(&optional buffer file newfile)
    "Rename current BUFFER name and FILE name for NEWFILE."
    (interactive (let* ((buffer (current-buffer))
                        (file (buffer-file-name))
                        (newfile (and file
                                      (expand-file-name (read-file-name "File and Buffer New Name: ")))))
                   (list buffer file newfile)))
    ;; 读取新文件名
    (if (and buffer file newfile)
        ;; 如果新文件名为文件夹则放弃
        (if (not (directory-name-p newfile))
            (if-let ((newfile-dir (file-name-directory newfile)))
                ;; 判断新文件名所在文件夹是否存在
                (if (file-directory-p newfile-dir)
                    (progn
                      (rename-file file newfile 4)
                      (with-current-buffer buffer
                        ;; 更改缓冲区所在文件路径，同时更改缓冲区名称
                        (set-visited-file-name newfile)
                        ;; (rename-buffer (file-name-nondirectory newfile))
                        ))
                  ;; 是否创建新的文件夹
                  (when (yes-or-no-p
                         (format "\"%s\" directory is not exists, you sure make the new directory?"
                                 newfile-dir))
                    (make-directory newfile-dir)
                    (rename-file file newfile 4)
                    (with-current-buffer buffer
                      (set-visited-file-name newfile)
                      ))))
          (message "\"%s\" is a directory ! ! !" newfile))))


  (use-package evil
    :config
    (lmm/evil-space-leader-def
      "tw" 'lmm/translate-word-at-point
      "cf" 'lmm/rename-buffer-and-file-name))

#+END_SRC

** Google Translate
#+BEGIN_SRC emacs-lisp
  (use-package google-translate
    :straight t
    :init
    (setq google-translate-default-source-language "en"
          google-translate-default-target-language "zh-CN"
          google-translate-pop-up-buffer-set-focus t)
    :bind
    (:map lmm/evil-space-leader-def-map
          ("t." . google-translate-at-point)))
#+END_SRC

** AI
#+BEGIN_SRC emacs-lisp
  (use-package gptel
    :straight t
    :defer t
    :config
    (setq
     gptel-model "gemini-2.0-flash"
     gptel-backend (gptel-make-gemini "Gemini"
                     :key 'gptel-api-key-from-auth-source
                     :stream t)
     gptel-proxy (when-let* ((addr (alist-get "http" url-proxy-services nil nil 'equal)))
                   (concat "http://" addr))
     gptel-default-mode #'markdown-mode)
    (add-to-list 'gptel-directives '(translator . "你是一个好用的翻译助手。请将我的英文翻译成中文，将所有非中文的翻译成中文。我发给你所有的话都是需要翻译的内容，你只需要回答翻译结果。翻译结果请符合中文的语言习惯。"))
    (add-to-list 'gptel-directives '(default . ""))
    (setq gptel--system-message (alist-get 'default gptel-directives)))
#+END_SRC
** 文件操作
#+BEGIN_SRC emacs-lisp
  (defun lmm/open-file-in-remote-sudo(file)
    "Open FILE as remote root"
    (interactive)
    (find-file (if (file-remote-p file)
                   (concat "/" (file-remote-p file 'method) ":"
                           (file-remote-p file 'user) "@" (file-remote-p file 'host)
                           "|sudo:root@"
                           (file-remote-p file 'host) ":" (file-remote-p file 'localname))
                 (user-error "This is not remote file"))))


  (defvar lmmv/sudo-localhost "/sudo:root@localhost:"
    "Sudo localhost name")

  (defun lmm/open-file-in-localhost-sudo(file)
    "Open FILE as root"
    (interactive)
    (find-file (concat lmmv/sudo-localhost (expand-file-name file))))

  (defun lmm/conver-sudo-file-name(file)
    "Conver FILE to sudo path"
    (concat lmmv/sudo-localhost (expand-file-name file)))

  ;;;###autoload
  (defun lmm/sudo-find-file (file)
    "Open FILE as root."
    (interactive "FOpen file as root: ")
    (let ((file (expand-file-name file)))
      (cond
       ;; 如果是一个文件夹并存在
       ((file-directory-p file)
        (lmm/read-char-choice
            (format "\"%s\" is directory, sure open in sudo('y' -> yes, '.' -> not sudo open, 'n' or 'q' -> quit)" file)
          ((?y (lmm/open-file-in-localhost-sudo file))
           (?. (find-file file))
           (?n nil)
           (?q nil))))

       ;; 如果是一个文件夹但不存在
       ((directory-name-p file)
        (lmm/read-char-choice
            (format "\"%s\" is new directory, sure make it on sudo('y':make sudo + sudo open, '.':make + open, 'r':make sudo, 'u':make, 'n'|'q':quit)?" file)
          ((?y (let ((fs (lmm/conver-sudo-file-name file)))
                 (make-directory fs t)
                 (if (file-directory-p fs)
                     (find-file fs)
                   (user-error (format "\"%s create filed!\"" file)))))
           (?. (make-directory file t)
               (if (file-directory-p file)
                   (find-file file)
                 (user-error (format "\"%s create filed!\"" file))))
           (?r (make-directory (lmm/conver-sudo-file-name file) t))
           (?u (make-directory file t))
           (?n nil)
           (?q nil))))

       ;; 如果是一个文件并直接可写
       ((file-writable-p file)
        (lmm/read-char-choice
            (format "File \"%s\" is user writeable, sure open in sudo('y':sudo open, '.':open, 'n'|'q':quit)?" file)
          ((?y (lmm/open-file-in-localhost-sudo file))
           (?. (find-file file))
           (?n nil)
           (?q nil))))

       ;; 如果是一个文件并不能直接可写
       ((file-exists-p file) (lmm/open-file-in-localhost-sudo file))

       ;; 如果该文件不存在
       (t nil)
       )))
  (defun +sudo-reopen-this-buffer ()
    "Open this buffer file in sudo."
    (interactive)
    (if-let* ((current-buffer (current-buffer))
              (file (buffer-file-name current-buffer)))
        (when-let ((file-buffer (find-file-noselect (concat "/sudo::" file))))
          (switch-to-buffer file-buffer)
          (kill-buffer current-buffer))
      (user-error "The current buffer does not come from an existing file.")))
#+END_SRC

** News
#+BEGIN_SRC emacs-lisp
  (use-package elfeed
    :straight t
    :commands elfeed)
#+END_SRC

** Hyperbole 上下文操作
#+BEGIN_SRC emacs-lisp
  (use-package hyperbole
    :straight t
    :bind
    ("M-RET" . hkey-either)
    :commands (hkey-either hyperbole))
#+END_SRC

** Insert current time
#+BEGIN_SRC emacs-lisp
  (defun lmm/insert-current-time()
    "Insert current time, select format."
    (interactive)
    (insert
     (completing-read "Select time format: "
                      (let ((time (current-time))
                            (format-string-list '("yyyy-mm-dd                   -> %F"
                                                  "dd-mm-yyyy                   -> %d-%m-%Y"
                                                  "mm/dd/yy                     -> %D"
                                                  "%R"
                                                  "%T"
                                                  "%r"
                                                  "yyyy-mm-dd HH:MM:SS(24-hour) -> %F %T"
                                                  "yyyy-mm-dd HH:MM:SS(12-hour) -> %F %r"
                                                  "%Y %m %d %A"
                                                  "%F-%R"
                                                  "%Y %m %d %H:%M"
                                                  "%c"
                                                  "%x")))
                        (mapcar (lambda(s)(format-time-string s time)) format-string-list)))))
#+END_SRC
